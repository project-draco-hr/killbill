{
  final SubscriptionBundle bundle;
  try {
    bundle=entitlementApi.getBundleFromId(bundleId,context);
  }
 catch (  EntitlementUserApiException e) {
    log.warn("Ignoring update for bundle {}: bundle does not exist",bundleId);
    return;
  }
  final Account account;
  try {
    account=accountApi.getAccountById(bundle.getAccountId(),context);
  }
 catch (  AccountApiException e) {
    log.warn("Ignoring update for bundle {}: account {} does not exist",bundleId,bundle.getAccountId());
    return;
  }
  final String accountKey=account.getExternalKey();
  final String externalKey=bundle.getExternalKey();
  overdueStatusSqlDao.inTransaction(new Transaction<Void,BusinessOverdueStatusSqlDao>(){
    @Override public Void inTransaction(    final BusinessOverdueStatusSqlDao transactional,    final TransactionStatus status) throws Exception {
      log.info("Started rebuilding overdue statuses for bundle id {}",bundleId);
      transactional.deleteOverdueStatusesForBundle(bundleId.toString(),context);
      final List<BlockingState> blockingHistory=junctionApi.getBlockingHistory(bundleId,context.toTenantContext());
      if (blockingHistory != null && blockingHistory.size() > 0) {
        final List<BlockingState> overdueStates=ImmutableList.<BlockingState>copyOf(blockingHistory);
        final List<BlockingState> overdueStatesReversed=Lists.reverse(overdueStates);
        DateTime previousStartDate=null;
        for (        final BlockingState state : overdueStatesReversed) {
          final BusinessOverdueStatusModelDao overdueStatus=new BusinessOverdueStatusModelDao(accountKey,bundleId,previousStartDate,externalKey,state.getTimestamp(),state.getStateName());
          log.info("Adding overdue state {}",overdueStatus);
          overdueStatusSqlDao.createOverdueStatus(overdueStatus,context);
          previousStartDate=state.getTimestamp();
        }
      }
      log.info("Finished rebuilding overdue statuses for bundle id {}",bundleId);
      return null;
    }
  }
);
}
