{
  try {
    final Account account=accountApi.getAccountById(bundle.getAccountId(),context);
    final SortedSet<Invoice> unpaidInvoices=unpaidInvoicesForBundle(bundle.getId(),bundle.getAccountId(),account.getTimeZone(),context);
    final Subscription basePlan=getBasePlanIfExist(bundle.getId(),context);
    final UUID id=bundle.getId();
    final int numberOfUnpaidInvoices=unpaidInvoices.size();
    final BigDecimal unpaidInvoiceBalance=sumBalance(unpaidInvoices);
    LocalDate dateOfEarliestUnpaidInvoice=null;
    UUID idOfEarliestUnpaidInvoice=null;
    final Invoice invoice=earliest(unpaidInvoices);
    if (invoice != null) {
      dateOfEarliestUnpaidInvoice=invoice.getInvoiceDate();
      idOfEarliestUnpaidInvoice=invoice.getId();
    }
    final PaymentResponse responseForLastFailedPayment=PaymentResponse.INSUFFICIENT_FUNDS;
    final Tag[] tags=new Tag[]{};
    final Product basePlanProduct;
    final BillingPeriod basePlanBillingPeriod;
    final PriceList basePlanPriceList;
    final PhaseType basePlanPhaseType;
    if (basePlan == null || basePlan.getCurrentPlan() == null) {
      basePlanProduct=null;
      basePlanBillingPeriod=null;
      basePlanPriceList=null;
      basePlanPhaseType=null;
    }
 else {
      basePlanProduct=basePlan.getCurrentPlan().getProduct();
      basePlanBillingPeriod=basePlan.getCurrentPlan().getBillingPeriod();
      basePlanPriceList=basePlan.getCurrentPriceList();
      basePlanPhaseType=basePlan.getCurrentPhase().getPhaseType();
    }
    return new BillingStateBundle(id,numberOfUnpaidInvoices,unpaidInvoiceBalance,dateOfEarliestUnpaidInvoice,account.getTimeZone(),idOfEarliestUnpaidInvoice,responseForLastFailedPayment,tags,basePlanProduct,basePlanBillingPeriod,basePlanPriceList,basePlanPhaseType);
  }
 catch (  SubscriptionUserApiException e) {
    throw new OverdueException(e);
  }
catch (  AccountApiException e) {
    throw new OverdueException(e);
  }
}
