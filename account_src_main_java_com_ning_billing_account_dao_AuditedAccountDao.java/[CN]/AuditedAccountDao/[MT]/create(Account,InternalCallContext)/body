{
  final String key=account.getExternalKey();
  try {
    transactionalSqlDao.execute(new EntitySqlDaoTransactionWrapper<Void>(){
      @Override public Void inTransaction(      final EntitySqlDaoWrapperFactory<EntitySqlDao> entitySqlDaoWrapperFactory) throws AccountApiException, InternalBus.EventBusException {
        final AccountSqlDao transactionalDao=entitySqlDaoWrapperFactory.become(AccountSqlDao.class);
        final Account currentAccount=transactionalDao.getAccountByKey(key,context);
        if (currentAccount != null) {
          throw new AccountApiException(ErrorCode.ACCOUNT_ALREADY_EXISTS,key);
        }
        transactionalDao.create(account,context);
        final Long recordId=accountSqlDao.getRecordId(account.getId().toString(),context);
        final InternalCallContext rehydratedContext=internalCallContextFactory.createInternalCallContext(recordId,context);
        final AccountCreationInternalEvent creationEvent=new DefaultAccountCreationEvent(account,rehydratedContext.getUserToken(),context.getAccountRecordId(),context.getTenantRecordId());
        try {
          eventBus.postFromTransaction(creationEvent,transactionalDao,rehydratedContext);
        }
 catch (        final EventBusException e) {
          log.warn("Failed to post account creation event for account " + account.getId(),e);
        }
        return null;
      }
    }
);
  }
 catch (  final RuntimeException re) {
    if (re.getCause() instanceof EntityPersistenceException) {
      throw (EntityPersistenceException)re.getCause();
    }
 else     if (re.getCause() instanceof DataTruncation) {
      throw new EntityPersistenceException(ErrorCode.DATA_TRUNCATION,re.getCause().getMessage());
    }
 else {
      throw re;
    }
  }
}
