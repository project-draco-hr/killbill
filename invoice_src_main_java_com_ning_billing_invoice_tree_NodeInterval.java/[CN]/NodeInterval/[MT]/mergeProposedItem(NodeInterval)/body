{
  Preconditions.checkState(newNode.getItems().size() == 1,"Expected new node to have only one item");
  final Item newNodeItem=newNode.getItems().get(0);
  if (!isRoot() && newNodeItem.getStartDate().compareTo(start) == 0 && newNodeItem.getEndDate().compareTo(end) == 0) {
    items.cancelItems(newNodeItem);
    return true;
  }
  computeRootInterval(newNode);
  if (leftChild == null) {
    leftChild=newNode;
    return true;
  }
  NodeInterval prevChild=null;
  NodeInterval curChild=leftChild;
  do {
    Preconditions.checkState(!curChild.isItemOverlap(newNodeItem),"Item " + newNodeItem + " overlaps "+ curChild);
    if (curChild.isItemContained(newNodeItem)) {
      final Item existingNodeItem=curChild.getItems().get(0);
      Preconditions.checkState(curChild.getItems().size() == 1,"Expected existing node to have only one item");
      if (existingNodeItem.isSameKind(newNodeItem)) {
        curChild.mergeProposedItem(newNode);
        return true;
      }
 else {
        return false;
      }
    }
    if (newNodeItem.getStartDate().compareTo(curChild.getStart()) < 0) {
      newNode.rightSibling=curChild;
      if (prevChild == null) {
        leftChild=newNode;
      }
 else {
        prevChild.rightSibling=newNode;
      }
      return true;
    }
    prevChild=curChild;
    curChild=curChild.rightSibling;
  }
 while (curChild != null);
  prevChild.rightSibling=newNode;
  return true;
}
