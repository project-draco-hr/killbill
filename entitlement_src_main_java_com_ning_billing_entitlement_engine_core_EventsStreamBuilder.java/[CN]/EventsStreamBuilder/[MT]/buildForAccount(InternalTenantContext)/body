{
  final Map<UUID,List<SubscriptionBase>> subscriptions=subscriptionInternalApi.getSubscriptionsForAccount(internalTenantContext);
  if (subscriptions.isEmpty()) {
    return ImmutableList.<EventsStream>of();
  }
  final UUID accountId=nonEntityDao.retrieveIdFromObject(internalTenantContext.getAccountRecordId(),ObjectType.ACCOUNT);
  final Account account;
  try {
    account=accountInternalApi.getAccountById(accountId,internalTenantContext);
  }
 catch (  AccountApiException e) {
    throw new EntitlementApiException(e);
  }
  final List<SubscriptionBaseBundle> bundles=subscriptionInternalApi.getBundlesForAccount(accountId,internalTenantContext);
  final Map<UUID,SubscriptionBaseBundle> bundlesPerId=new HashMap<UUID,SubscriptionBaseBundle>();
  for (  final SubscriptionBaseBundle bundle : bundles) {
    bundlesPerId.put(bundle.getId(),bundle);
  }
  final List<BlockingState> blockingStatesForAccount=BLOCKING_STATE_ORDERING.immutableSortedCopy(defaultBlockingStateDao.getBlockingAllForAccountRecordId(internalTenantContext));
  final List<BlockingState> accountEntitlementStates=ImmutableList.<BlockingState>copyOf(Iterables.<BlockingState>filter(blockingStatesForAccount,new Predicate<BlockingState>(){
    @Override public boolean apply(    final BlockingState input){
      return BlockingStateType.ACCOUNT.equals(input.getType()) && EntitlementService.ENTITLEMENT_SERVICE_NAME.equals(input.getService()) && accountId.equals(input.getBlockedId());
    }
  }
));
  final List<EventsStream> results=new LinkedList<EventsStream>();
  for (  final UUID bundleId : subscriptions.keySet()) {
    final SubscriptionBaseBundle bundle=bundlesPerId.get(bundleId);
    final List<SubscriptionBase> allSubscriptionsForBundle=subscriptions.get(bundleId);
    final SubscriptionBase baseSubscription=Iterables.<SubscriptionBase>tryFind(allSubscriptionsForBundle,new Predicate<SubscriptionBase>(){
      @Override public boolean apply(      final SubscriptionBase input){
        return ProductCategory.BASE.equals(input.getLastActiveProduct().getCategory());
      }
    }
).orNull();
    final List<BlockingState> bundleEntitlementStates=ImmutableList.<BlockingState>copyOf(Iterables.<BlockingState>filter(blockingStatesForAccount,new Predicate<BlockingState>(){
      @Override public boolean apply(      final BlockingState input){
        return BlockingStateType.SUBSCRIPTION_BUNDLE.equals(input.getType()) && EntitlementService.ENTITLEMENT_SERVICE_NAME.equals(input.getService()) && bundle.getId().equals(input.getBlockedId());
      }
    }
));
    for (    final SubscriptionBase subscription : allSubscriptionsForBundle) {
      final List<BlockingState> subscriptionEntitlementStates=(baseSubscription == null || subscription.getId().equals(baseSubscription.getId())) ? ImmutableList.<BlockingState>copyOf(Iterables.<BlockingState>filter(blockingStatesForAccount,new Predicate<BlockingState>(){
        @Override public boolean apply(        final BlockingState input){
          return BlockingStateType.SUBSCRIPTION.equals(input.getType()) && EntitlementService.ENTITLEMENT_SERVICE_NAME.equals(input.getService()) && subscription.getId().equals(input.getBlockedId());
        }
      }
)) : BLOCKING_STATE_ORDERING.immutableSortedCopy(blockingStateDao.getBlockingHistoryForService(subscription.getId(),BlockingStateType.SUBSCRIPTION,EntitlementService.ENTITLEMENT_SERVICE_NAME,internalTenantContext));
      results.add(buildForEntitlement(account,bundle,baseSubscription,subscription,allSubscriptionsForBundle,subscriptionEntitlementStates,bundleEntitlementStates,accountEntitlementStates,internalTenantContext));
    }
  }
  return results;
}
