{
  if (subscriptions.isEmpty()) {
    return new DefaultAccountEventsStreams(account);
  }
  final List<SubscriptionBaseBundle> bundles=subscriptionInternalApi.getBundlesForAccount(account.getId(),internalTenantContext);
  final Map<UUID,SubscriptionBaseBundle> bundlesPerId=new HashMap<UUID,SubscriptionBaseBundle>();
  for (  final SubscriptionBaseBundle bundle : bundles) {
    bundlesPerId.put(bundle.getId(),bundle);
  }
  final List<BlockingState> blockingStatesForAccount=BLOCKING_STATE_ORDERING.immutableSortedCopy(defaultBlockingStateDao.getBlockingAllForAccountRecordId(internalTenantContext));
  final List<BlockingState> accountEntitlementStates=new LinkedList<BlockingState>();
  final Map<UUID,List<BlockingState>> entitlementStatesPerSubscription=new HashMap<UUID,List<BlockingState>>();
  final Map<UUID,List<BlockingState>> entitlementStatesPerBundle=new HashMap<UUID,List<BlockingState>>();
  for (  final BlockingState blockingState : blockingStatesForAccount) {
    if (!EntitlementService.ENTITLEMENT_SERVICE_NAME.equals(blockingState.getService())) {
      continue;
    }
 else     if (BlockingStateType.SUBSCRIPTION.equals(blockingState.getType())) {
      if (entitlementStatesPerSubscription.get(blockingState.getBlockedId()) == null) {
        entitlementStatesPerSubscription.put(blockingState.getBlockedId(),new LinkedList<BlockingState>());
      }
      entitlementStatesPerSubscription.get(blockingState.getBlockedId()).add(blockingState);
    }
 else     if (BlockingStateType.SUBSCRIPTION_BUNDLE.equals(blockingState.getType())) {
      if (entitlementStatesPerBundle.get(blockingState.getBlockedId()) == null) {
        entitlementStatesPerBundle.put(blockingState.getBlockedId(),new LinkedList<BlockingState>());
      }
      entitlementStatesPerBundle.get(blockingState.getBlockedId()).add(blockingState);
    }
 else     if (BlockingStateType.ACCOUNT.equals(blockingState.getType()) && account.getId().equals(blockingState.getBlockedId())) {
      accountEntitlementStates.add(blockingState);
    }
  }
  final Map<UUID,Collection<EventsStream>> entitlementsPerBundle=new HashMap<UUID,Collection<EventsStream>>();
  for (  final UUID bundleId : subscriptions.keySet()) {
    final SubscriptionBaseBundle bundle=bundlesPerId.get(bundleId);
    final List<SubscriptionBase> allSubscriptionsForBundle=subscriptions.get(bundleId);
    final SubscriptionBase baseSubscription=Iterables.<SubscriptionBase>tryFind(allSubscriptionsForBundle,new Predicate<SubscriptionBase>(){
      @Override public boolean apply(      final SubscriptionBase input){
        return ProductCategory.BASE.equals(input.getLastActiveProduct().getCategory());
      }
    }
).orNull();
    final List<BlockingState> bundleEntitlementStates=Objects.firstNonNull(entitlementStatesPerBundle.get(bundleId),ImmutableList.<BlockingState>of());
    if (entitlementsPerBundle.get(bundleId) == null) {
      entitlementsPerBundle.put(bundleId,new LinkedList<EventsStream>());
    }
    for (    final SubscriptionBase subscription : allSubscriptionsForBundle) {
      final List<BlockingState> subscriptionBlockingStatesOnDisk=Objects.firstNonNull(entitlementStatesPerSubscription.get(subscription.getId()),ImmutableList.<BlockingState>of());
      final List<BlockingState> subscriptionEntitlementStates=(baseSubscription == null || subscription.getId().equals(baseSubscription.getId())) ? subscriptionBlockingStatesOnDisk : blockingStateDao.getBlockingHistoryForService(subscriptionBlockingStatesOnDisk,bundle,baseSubscription,subscription,allSubscriptionsForBundle,internalTenantContext);
      final EventsStream eventStream=buildForEntitlement(account,bundle,baseSubscription,subscription,allSubscriptionsForBundle,subscriptionEntitlementStates,bundleEntitlementStates,accountEntitlementStates,internalTenantContext);
      entitlementsPerBundle.get(bundleId).add(eventStream);
    }
  }
  return new DefaultAccountEventsStreams(account,bundles,entitlementsPerBundle);
}
