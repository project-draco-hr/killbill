{
  super(id,createdDate,updatedDate);
  this.accountId=accountId;
  this.paymentMethodId=paymentMethodId;
  this.paymentNumber=paymentNumber;
  this.externalKey=externalKey;
  this.transactions=transactions;
  final Collection<PaymentTransaction> voidedTransactions=new LinkedList<PaymentTransaction>();
  final Collection<PaymentTransaction> nonVoidedTransactions=new LinkedList<PaymentTransaction>();
  int nvTxToVoid=0;
  for (  final PaymentTransaction paymentTransaction : Lists.<PaymentTransaction>reverse(transactions)) {
    if (TransactionStatus.SUCCESS.equals(paymentTransaction.getTransactionStatus())) {
      if (paymentTransaction.getTransactionType() == TransactionType.VOID) {
        nvTxToVoid++;
      }
 else {
        if (nvTxToVoid > 0) {
          nvTxToVoid--;
          voidedTransactions.add(paymentTransaction);
        }
 else {
          nonVoidedTransactions.add(paymentTransaction);
        }
      }
    }
  }
  this.authAmount=getAmountForType(nonVoidedTransactions,TransactionType.AUTHORIZE);
  this.captureAmount=getAmountForType(nonVoidedTransactions,TransactionType.CAPTURE);
  this.purchasedAmount=getAmountForType(nonVoidedTransactions,TransactionType.PURCHASE);
  this.creditAmount=getAmountForType(nonVoidedTransactions,TransactionType.CREDIT);
  this.refundAmount=getAmountForType(nonVoidedTransactions,TransactionType.REFUND);
  this.isAuthVoided=Iterables.<PaymentTransaction>tryFind(voidedTransactions,new Predicate<PaymentTransaction>(){
    @Override public boolean apply(    final PaymentTransaction input){
      return input.getTransactionType() == TransactionType.AUTHORIZE && TransactionStatus.SUCCESS.equals(input.getTransactionStatus());
    }
  }
).isPresent();
  this.currency=!transactions.isEmpty() ? transactions.get(0).getCurrency() : null;
}
