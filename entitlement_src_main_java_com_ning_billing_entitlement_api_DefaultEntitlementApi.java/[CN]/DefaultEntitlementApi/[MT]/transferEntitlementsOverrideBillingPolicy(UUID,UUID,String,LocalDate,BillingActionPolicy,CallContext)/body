{
  final boolean cancelImm;
switch (billingPolicy) {
case IMMEDIATE:
    cancelImm=true;
  break;
case END_OF_TERM:
cancelImm=false;
break;
default :
throw new RuntimeException("Unexpected billing policy " + billingPolicy);
}
final InternalCallContext contextWithValidAccountRecordId=internalCallContextFactory.createInternalCallContext(sourceAccountId,context);
try {
final SubscriptionBaseBundle bundle=subscriptionInternalApi.getActiveBundleForKey(externalKey,contextWithValidAccountRecordId);
if (!bundle.getAccountId().equals(sourceAccountId)) {
throw new EntitlementApiException(new SubscriptionBaseApiException(ErrorCode.SUB_GET_INVALID_BUNDLE_KEY,externalKey));
}
final SubscriptionBase baseSubscription=subscriptionInternalApi.getBaseSubscription(bundle.getId(),contextWithValidAccountRecordId);
final DateTime requestedDate=dateHelper.fromLocalDateAndReferenceTime(effectiveDate,baseSubscription.getStartDate(),contextWithValidAccountRecordId);
final SubscriptionBaseBundle newBundle=subscriptionTransferApi.transferBundle(sourceAccountId,destAccountId,externalKey,requestedDate,true,cancelImm,context);
for (final SubscriptionBase subscriptionBase : subscriptionInternalApi.getSubscriptionsForBundle(bundle.getId(),contextWithValidAccountRecordId)) {
final BlockingState blockingState=new DefaultBlockingState(subscriptionBase.getId(),BlockingStateType.SUBSCRIPTION,DefaultEntitlementApi.ENT_STATE_CANCELLED,EntitlementService.ENTITLEMENT_SERVICE_NAME,true,true,false,requestedDate);
entitlementUtils.setBlockingStateAndPostBlockingTransitionEvent(blockingState,contextWithValidAccountRecordId);
}
return newBundle.getId();
}
 catch (SubscriptionBaseTransferApiException e) {
throw new EntitlementApiException(e);
}
catch (SubscriptionBaseApiException e) {
throw new EntitlementApiException(e);
}
}
