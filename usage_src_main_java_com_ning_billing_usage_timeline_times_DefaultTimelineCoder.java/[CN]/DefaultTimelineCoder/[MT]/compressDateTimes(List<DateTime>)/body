{
  final ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  final DataOutputStream dataStream=new DataOutputStream(outputStream);
  try {
    int lastTime=0;
    int lastDelta=0;
    int repeatCount=0;
    for (    final DateTime time : times) {
      final int newTime=DateTimeUtils.unixSeconds(time);
      if (lastTime == 0) {
        lastTime=newTime;
        writeTime(0,lastTime,dataStream);
        continue;
      }
 else       if (newTime < lastTime) {
        log.warn("In TimelineCoder.compressTimes(), newTime {} is < lastTime {}; ignored",newTime,lastTime);
        continue;
      }
      final int delta=newTime - lastTime;
      final boolean deltaWorks=delta <= TimelineOpcode.MAX_DELTA_TIME;
      final boolean sameDelta=repeatCount > 0 && delta == lastDelta;
      if (deltaWorks) {
        if (sameDelta) {
          repeatCount++;
          if (repeatCount == MAX_SHORT_REPEAT_COUNT) {
            writeRepeatedDelta(delta,repeatCount,dataStream);
            repeatCount=0;
          }
        }
 else {
          if (repeatCount > 0) {
            writeRepeatedDelta(lastDelta,repeatCount,dataStream);
          }
          repeatCount=1;
        }
        lastDelta=delta;
      }
 else {
        if (repeatCount > 0) {
          writeRepeatedDelta(lastDelta,repeatCount,dataStream);
        }
        writeTime(0,newTime,dataStream);
        repeatCount=0;
        lastDelta=0;
      }
      lastTime=newTime;
    }
    if (repeatCount > 0) {
      writeRepeatedDelta(lastDelta,repeatCount,dataStream);
    }
    dataStream.flush();
    return outputStream.toByteArray();
  }
 catch (  IOException e) {
    log.error("Exception compressing times list of length {}",times.size(),e);
    return null;
  }
}
