{
  try {
    SubscriptionTransition lastPlanTransition=subscription.getInitialTransitionForCurrentPlan();
    if (effectiveDate.isBefore(lastPlanTransition.getEffectiveTransitionTime())) {
      throw new EntitlementError(String.format("Cannot specify an effectiveDate prior to last Plan Change, subscription = %s, effectiveDate = %s",subscription.getId(),effectiveDate));
    }
switch (lastPlanTransition.getTransitionType()) {
case CREATE:
      List<TimedPhase> timedPhases=getTimedPhaseOnCreate(subscription.getStartDate(),subscription.getBundleStartDate(),lastPlanTransition.getNextPlan(),lastPlanTransition.getNextPhase().getPhaseType(),lastPlanTransition.getNextPriceList());
    return getTimedPhase(timedPhases,effectiveDate,WhichPhase.NEXT);
case CHANGE:
  return getTimedPhaseOnChange(subscription.getStartDate(),subscription.getBundleStartDate(),lastPlanTransition.getPreviousPhase(),lastPlanTransition.getPreviousPlan(),lastPlanTransition.getPreviousPriceList(),lastPlanTransition.getNextPlan(),lastPlanTransition.getNextPriceList(),effectiveDate,WhichPhase.NEXT);
default :
throw new EntitlementError(String.format("Unexpectd initial transition %s for current plan %s on subscription %s",lastPlanTransition.getTransitionType(),subscription.getCurrentPlan(),subscription.getId()));
}
}
 catch (Exception e) {
throw new EntitlementError(String.format("Could not compute next phase change for subscription %s",subscription.getId()),e);
}
}
