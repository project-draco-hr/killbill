{
  try {
    SubscriptionTransition lastPlanTransition=subscription.getInitialTransitionForCurrentPlan();
    if (effectiveDate.isBefore(lastPlanTransition.getEffectiveTransitionTime())) {
      throw new EntitlementError(String.format("Cannot specify an effectiveDate prior to last Plan Change, subscription = %s, effectiveDate = %s",subscription.getId(),effectiveDate));
    }
switch (lastPlanTransition.getTransitionType()) {
case CREATE:
      DateTime initialStartPhase=subscription.getStartDate();
    PhaseType initialPhase=lastPlanTransition.getNextPhase().getPhaseType();
  List<TimedPhase> timedPhases=getPhaseAlignments(subscription.getCurrentPlan(),initialPhase,initialStartPhase);
return getTimedPhase(timedPhases,effectiveDate,WhichPhase.NEXT);
case CHANGE:
return getTimedPhaseOnChange(subscription.getStartDate(),subscription.getBundleStartDate(),lastPlanTransition.getPreviousPhase(),lastPlanTransition.getPreviousPlan(),lastPlanTransition.getPreviousPriceList(),lastPlanTransition.getNextPlan(),lastPlanTransition.getNextPriceList(),effectiveDate,WhichPhase.NEXT);
default :
throw new EntitlementError(String.format("Unexpectd initial transition %s for current plan %s on subscription %s",lastPlanTransition.getTransitionType(),subscription.getCurrentPlan(),subscription.getId()));
}
}
 catch (Exception e) {
throw new EntitlementError(String.format("Could not compute next phase change for subscription %s",subscription.getId()),e);
}
}
