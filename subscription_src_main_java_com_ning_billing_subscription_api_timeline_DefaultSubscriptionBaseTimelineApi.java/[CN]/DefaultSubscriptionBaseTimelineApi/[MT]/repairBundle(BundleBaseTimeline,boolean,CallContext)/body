{
  final InternalTenantContext tenantContext=internalCallContextFactory.createInternalTenantContext(context);
  try {
    final SubscriptionBaseBundle bundle=dao.getSubscriptionBundleFromId(input.getId(),tenantContext);
    if (bundle == null) {
      throw new SubscriptionBaseRepairException(ErrorCode.SUB_REPAIR_UNKNOWN_BUNDLE,input.getId());
    }
    final List<SubscriptionDataRepair> subscriptions=convertToSubscriptionsDataRepair(dao.getSubscriptions(input.getId(),tenantContext));
    if (subscriptions.size() == 0) {
      throw new SubscriptionBaseRepairException(ErrorCode.SUB_REPAIR_NO_ACTIVE_SUBSCRIPTIONS,input.getId());
    }
    final String viewId=getViewId(((DefaultSubscriptionBaseBundle)bundle).getLastSysUpdateDate(),subscriptions);
    if (!viewId.equals(input.getViewId())) {
      throw new SubscriptionBaseRepairException(ErrorCode.SUB_REPAIR_VIEW_CHANGED,input.getId(),input.getViewId(),viewId);
    }
    DateTime firstDeletedBPEventTime=null;
    DateTime lastRemainingBPEventTime=null;
    boolean isBasePlanRecreate=false;
    DateTime newBundleStartDate=null;
    SubscriptionDataRepair baseSubscriptionRepair=null;
    final List<SubscriptionDataRepair> addOnSubscriptionInRepair=new LinkedList<SubscriptionDataRepair>();
    final List<SubscriptionDataRepair> inRepair=new LinkedList<SubscriptionDataRepair>();
    for (    final SubscriptionBase cur : subscriptions) {
      final SubscriptionBaseTimeline curRepair=findAndCreateSubscriptionRepair(cur.getId(),input.getSubscriptions());
      if (curRepair != null) {
        final SubscriptionDataRepair curInputRepair=((SubscriptionDataRepair)cur);
        final List<SubscriptionEvent> remaining=getRemainingEventsAndValidateDeletedEvents(curInputRepair,firstDeletedBPEventTime,curRepair.getDeletedEvents());
        final boolean isPlanRecreate=(curRepair.getNewEvents().size() > 0 && (curRepair.getNewEvents().get(0).getSubscriptionTransitionType() == SubscriptionBaseTransitionType.CREATE || curRepair.getNewEvents().get(0).getSubscriptionTransitionType() == SubscriptionBaseTransitionType.RE_CREATE));
        final DateTime newSubscriptionStartDate=isPlanRecreate ? curRepair.getNewEvents().get(0).getRequestedDate() : null;
        if (isPlanRecreate && remaining.size() != 0) {
          throw new SubscriptionBaseRepairException(ErrorCode.SUB_REPAIR_SUB_RECREATE_NOT_EMPTY,cur.getId(),cur.getBundleId());
        }
        if (!isPlanRecreate && remaining.size() == 0) {
          throw new SubscriptionBaseRepairException(ErrorCode.SUB_REPAIR_SUB_EMPTY,cur.getId(),cur.getBundleId());
        }
        if (cur.getCategory() == ProductCategory.BASE) {
          final int bpTransitionSize=((DefaultSubscriptionBase)cur).getAllTransitions().size();
          lastRemainingBPEventTime=(remaining.size() > 0) ? curInputRepair.getAllTransitions().get(remaining.size() - 1).getEffectiveTransitionTime() : null;
          firstDeletedBPEventTime=(remaining.size() < bpTransitionSize) ? curInputRepair.getAllTransitions().get(remaining.size()).getEffectiveTransitionTime() : null;
          isBasePlanRecreate=isPlanRecreate;
          newBundleStartDate=newSubscriptionStartDate;
        }
        if (curRepair.getNewEvents().size() > 0) {
          final DateTime lastRemainingEventTime=(remaining.size() == 0) ? null : curInputRepair.getAllTransitions().get(remaining.size() - 1).getEffectiveTransitionTime();
          validateFirstNewEvent(curInputRepair,curRepair.getNewEvents().get(0),lastRemainingBPEventTime,lastRemainingEventTime);
        }
        final SubscriptionDataRepair curOutputRepair=createSubscriptionDataRepair(curInputRepair,newBundleStartDate,newSubscriptionStartDate,remaining);
        repairDao.initializeRepair(curInputRepair.getId(),remaining,tenantContext);
        inRepair.add(curOutputRepair);
        if (curOutputRepair.getCategory() == ProductCategory.ADD_ON) {
          if (isPlanRecreate && (subscriptions.get(0)).getStartDate().isAfter(curRepair.getNewEvents().get(0).getRequestedDate())) {
            throw new SubscriptionBaseRepairException(ErrorCode.SUB_REPAIR_AO_CREATE_BEFORE_BP_START,cur.getId(),cur.getBundleId());
          }
          addOnSubscriptionInRepair.add(curOutputRepair);
        }
 else         if (curOutputRepair.getCategory() == ProductCategory.BASE) {
          baseSubscriptionRepair=curOutputRepair;
        }
      }
    }
    final RepairType repairType=getRepairType(subscriptions.get(0),(baseSubscriptionRepair != null));
switch (repairType) {
case BASE_REPAIR:
      for (      final SubscriptionBase cur : subscriptions) {
        if (cur.getCategory() == ProductCategory.ADD_ON && !inRepair.contains(cur)) {
          final SubscriptionDataRepair curOutputRepair=createSubscriptionDataRepair((SubscriptionDataRepair)cur,newBundleStartDate,null,((SubscriptionDataRepair)cur).getEvents());
          repairDao.initializeRepair(curOutputRepair.getId(),((SubscriptionDataRepair)cur).getEvents(),tenantContext);
          inRepair.add(curOutputRepair);
          addOnSubscriptionInRepair.add(curOutputRepair);
        }
      }
    break;
case ADD_ON_REPAIR:
  final SubscriptionDataRepair baseSubscription=(SubscriptionDataRepair)subscriptions.get(0);
baseSubscriptionRepair=createSubscriptionDataRepair(baseSubscription,baseSubscription.getBundleStartDate(),baseSubscription.getAlignStartDate(),baseSubscription.getEvents());
break;
case STANDALONE_REPAIR:
default :
break;
}
validateBasePlanRecreate(isBasePlanRecreate,subscriptions,input.getSubscriptions());
validateInputSubscriptionsKnown(subscriptions,input.getSubscriptions());
final Collection<NewEvent> newEvents=createOrderedNewEventInput(input.getSubscriptions());
for (final NewEvent newEvent : newEvents) {
final DefaultNewEvent cur=(DefaultNewEvent)newEvent;
final SubscriptionDataRepair curDataRepair=findSubscriptionDataRepair(cur.getSubscriptionId(),inRepair);
if (curDataRepair == null) {
throw new SubscriptionBaseRepairException(ErrorCode.SUB_REPAIR_UNKNOWN_SUBSCRIPTION,cur.getSubscriptionId());
}
curDataRepair.addNewRepairEvent(cur,baseSubscriptionRepair,addOnSubscriptionInRepair,context);
}
if (dryRun) {
baseSubscriptionRepair.addFutureAddonCancellation(addOnSubscriptionInRepair,context);
final List<SubscriptionBaseTimeline> repairs=createGetSubscriptionRepairList(subscriptions,convertDataRepair(inRepair));
return createGetBundleRepair(input.getId(),bundle.getExternalKey(),input.getViewId(),repairs);
}
 else {
dao.repair(bundle.getAccountId(),input.getId(),inRepair,internalCallContextFactory.createInternalCallContext(bundle.getAccountId(),context));
return getBundleTimeline(input.getId(),context);
}
}
 catch (CatalogApiException e) {
throw new SubscriptionBaseRepairException(e);
}
 finally {
repairDao.cleanup(tenantContext);
}
}
