{
  mockRetryProviderPlugin.setAborted(false).setNextRetryDate(null);
  mockRetryAuthorizeOperationCallback.setResult(null).setException(new PaymentApiException(ErrorCode.__UNKNOWN_ERROR_CODE,"bla"));
  runner.setOperationCallback(mockRetryAuthorizeOperationCallback).setContext(directPaymentStateContext);
  final State state=runner.fetchState("RETRIED");
  final UUID directTransactionId=UUID.randomUUID();
  paymentDao.insertPaymentAttemptWithProperties(new PaymentAttemptModelDao(account.getId(),paymentMethodId,utcNow,utcNow,directPaymentExternalKey,directTransactionId,directPaymentTransactionExternalKey,TransactionType.AUTHORIZE,state.getName(),amount,currency,null,EMPTY_PROPERTIES),internalCallContext);
  try {
    runner.run(state,false,TransactionType.AUTHORIZE,account,paymentMethodId,null,directPaymentExternalKey,directPaymentTransactionExternalKey,amount,currency,emptyProperties,null,callContext,internalCallContext);
    Assert.fail("Expecting paymentApiException...");
  }
 catch (  final PaymentApiException e) {
    final List<PaymentAttemptModelDao> pas=paymentDao.getPaymentAttemptByTransactionExternalKey(directPaymentTransactionExternalKey,internalCallContext);
    assertEquals(pas.size(),2);
    final PaymentAttemptModelDao failedAttempts=Iterables.tryFind(pas,new Predicate<PaymentAttemptModelDao>(){
      @Override public boolean apply(      final PaymentAttemptModelDao input){
        return input.getTransactionType() == TransactionType.AUTHORIZE && input.getStateName().equals("ABORTED");
      }
    }
).orNull();
    assertNotNull(failedAttempts);
  }
}
