{
  final int hostId=123;
  final int sampleKindId=456;
  final DateTime startTime=new DateTime();
  final List<DateTime> dateTimes=new ArrayList<DateTime>();
  final int shortRepeaterCount=256;
  final TimelineChunkAccumulator accum=new TimelineChunkAccumulator(hostId,sampleKindId,sampleCoder);
  for (int i=0; i < shortRepeaterCount; i++) {
    dateTimes.add(startTime.plusSeconds(i * 5));
    accum.addSample(sampleCoder.compressSample(new ScalarSample<Double>(SampleOpcode.DOUBLE,2.0)));
  }
  final DateTime endTime=startTime.plusSeconds(5 * shortRepeaterCount);
  final byte[] compressedTimes=timelineCoder.compressDateTimes(dateTimes);
  final TimelineChunk chunk=accum.extractTimelineChunkAndReset(startTime,endTime,compressedTimes);
  final byte[] samples=chunk.getTimeBytesAndSampleBytes().getSampleBytes();
  Assert.assertEquals(samples.length,5);
  Assert.assertEquals(((int)samples[0]) & 0xff,SampleOpcode.REPEAT_SHORT.getOpcodeIndex());
  final int count=((samples[1] & 0xff) << 8) | (samples[2] & 0xff);
  Assert.assertEquals(count,shortRepeaterCount);
  Assert.assertEquals(((int)samples[3]) & 0xff,SampleOpcode.BYTE_FOR_DOUBLE.getOpcodeIndex());
  Assert.assertEquals(((int)samples[4]) & 0xff,0x02);
  Assert.assertEquals(chunk.getSampleCount(),shortRepeaterCount);
  sampleCoder.scan(chunk.getTimeBytesAndSampleBytes().getSampleBytes(),compressedTimes,dateTimes.size(),new SampleProcessor(){
    @Override public void processSamples(    TimelineCursor timeCursor,    int sampleCount,    SampleOpcode opcode,    Object value){
      Assert.assertEquals(sampleCount,shortRepeaterCount);
      Assert.assertEquals(value,2.0);
    }
  }
);
}
