{
  final int hostId=123;
  final int sampleKindId=456;
  final DateTime startTime=new DateTime();
  final List<DateTime> dateTimes=new ArrayList<DateTime>();
  final int byteRepeaterCount=255;
  final TimelineChunkAccumulator accum=new TimelineChunkAccumulator(hostId,sampleKindId,sampleCoder);
  for (int i=0; i < byteRepeaterCount; i++) {
    dateTimes.add(startTime.plusSeconds(i * 5));
    accum.addSample(sampleCoder.compressSample(new ScalarSample<Double>(SampleOpcode.DOUBLE,2.0)));
  }
  final DateTime endTime=startTime.plusSeconds(5 * byteRepeaterCount);
  final byte[] compressedTimes=timelineCoder.compressDateTimes(dateTimes);
  final TimelineChunk chunk=accum.extractTimelineChunkAndReset(startTime,endTime,compressedTimes);
  final byte[] samples=chunk.getTimeBytesAndSampleBytes().getSampleBytes();
  Assert.assertEquals(samples.length,4);
  Assert.assertEquals(((int)samples[0]) & 0xff,SampleOpcode.REPEAT_BYTE.getOpcodeIndex());
  Assert.assertEquals(((int)samples[1]) & 0xff,byteRepeaterCount);
  Assert.assertEquals(((int)samples[2]) & 0xff,SampleOpcode.BYTE_FOR_DOUBLE.getOpcodeIndex());
  Assert.assertEquals(((int)samples[3]) & 0xff,0x02);
  Assert.assertEquals(chunk.getSampleCount(),byteRepeaterCount);
  sampleCoder.scan(chunk.getTimeBytesAndSampleBytes().getSampleBytes(),compressedTimes,dateTimes.size(),new SampleProcessor(){
    @Override public void processSamples(    final TimelineCursor timeCursor,    final int sampleCount,    final SampleOpcode opcode,    final Object value){
      Assert.assertEquals(sampleCount,byteRepeaterCount);
      Assert.assertEquals(value,2.0);
    }
  }
);
}
