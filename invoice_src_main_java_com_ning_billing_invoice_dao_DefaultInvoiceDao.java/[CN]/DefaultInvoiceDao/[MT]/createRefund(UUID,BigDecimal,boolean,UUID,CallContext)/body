{
  return invoicePaymentSqlDao.inTransaction(new Transaction<InvoicePayment,InvoicePaymentSqlDao>(){
    @Override public InvoicePayment inTransaction(    final InvoicePaymentSqlDao transactional,    final TransactionStatus status) throws Exception {
      final InvoicePayment payment=transactional.getByPaymentId(paymentId.toString());
      if (payment == null) {
        throw new InvoiceApiException(ErrorCode.INVOICE_PAYMENT_BY_ATTEMPT_NOT_FOUND,paymentId);
      }
      final BigDecimal maxRefundAmount=payment.getAmount() == null ? BigDecimal.ZERO : payment.getAmount();
      final BigDecimal requestedPositiveAmount=amount == null ? maxRefundAmount : amount;
      if (requestedPositiveAmount.compareTo(maxRefundAmount) > 0) {
        throw new InvoiceApiException(ErrorCode.REFUND_AMOUNT_TOO_HIGH,requestedPositiveAmount,maxRefundAmount);
      }
      final InvoicePayment existingRefund=transactional.getPaymentsForCookieId(paymentCookieId.toString());
      if (existingRefund != null) {
        return existingRefund;
      }
      final InvoicePayment refund=new DefaultInvoicePayment(UUID.randomUUID(),InvoicePaymentType.REFUND,paymentId,payment.getInvoiceId(),context.getCreatedDate(),requestedPositiveAmount.negate(),payment.getCurrency(),paymentCookieId,payment.getId());
      transactional.create(refund,context);
      final InvoiceSqlDao transInvoiceDao=transactional.become(InvoiceSqlDao.class);
      final Invoice invoice=transInvoiceDao.getById(payment.getInvoiceId().toString());
      if (invoice != null) {
        populateChildren(invoice,transInvoiceDao);
      }
 else {
        throw new IllegalStateException("Invoice shouldn't be null for payment " + payment.getId());
      }
      final BigDecimal invoiceBalanceAfterRefund=invoice.getBalance();
      final InvoiceItemSqlDao transInvoiceItemDao=transInvoiceDao.become(InvoiceItemSqlDao.class);
      final BigDecimal accountCbaAvailable=getAccountCBAFromTransaction(invoice.getAccountId(),transInvoiceDao);
      BigDecimal cbaAdjAmount=BigDecimal.ZERO;
      if (accountCbaAvailable.compareTo(BigDecimal.ZERO) > 0) {
        cbaAdjAmount=(requestedPositiveAmount.compareTo(accountCbaAvailable) > 0) ? accountCbaAvailable.negate() : requestedPositiveAmount.negate();
        final InvoiceItem cbaAdjItem=new CreditBalanceAdjInvoiceItem(invoice.getId(),invoice.getAccountId(),context.getCreatedDate(),cbaAdjAmount,invoice.getCurrency());
        transInvoiceItemDao.create(cbaAdjItem,context);
      }
      final BigDecimal requestedPositiveAmountAfterCbaAdj=requestedPositiveAmount.add(cbaAdjAmount);
      if (isInvoiceAdjusted) {
        final BigDecimal maxBalanceToAdjust=(invoiceBalanceAfterRefund.compareTo(BigDecimal.ZERO) <= 0) ? BigDecimal.ZERO : invoiceBalanceAfterRefund;
        final BigDecimal requestedPositiveAmountToAdjust=requestedPositiveAmountAfterCbaAdj.compareTo(maxBalanceToAdjust) > 0 ? maxBalanceToAdjust : requestedPositiveAmountAfterCbaAdj;
        if (requestedPositiveAmountToAdjust.compareTo(BigDecimal.ZERO) > 0) {
          final InvoiceItem adjItem=new RefundAdjInvoiceItem(invoice.getId(),invoice.getAccountId(),context.getCreatedDate(),requestedPositiveAmountToAdjust.negate(),invoice.getCurrency());
          transInvoiceItemDao.create(adjItem,context);
        }
      }
      return refund;
    }
  }
);
}
