{
  final UUID accountId=UUID.randomUUID();
  account=Mockito.mock(Account.class);
  Mockito.when(account.getId()).thenReturn(accountId);
  bundle=Mockito.mock(SubscriptionBundle.class);
  Mockito.when(bundle.getAccountId()).thenReturn(accountId);
  final UUID bundleId=UUID.randomUUID();
  Mockito.when(bundle.getId()).thenReturn(bundleId);
  Mockito.when(bundle.getKey()).thenReturn("key");
  subscription=Mockito.mock(Subscription.class);
  Mockito.when(subscription.getId()).thenReturn(UUID.randomUUID());
  Mockito.when(subscription.getBundleId()).thenReturn(bundleId);
  final Injector i=Guice.createInjector(new AbstractModule(){
    @Override protected void configure(){
      bind(BlockingChecker.class).to(DefaultBlockingChecker.class).asEagerSingleton();
      bind(BlockingStateDao.class).toInstance(dao);
      final EntitlementInternalApi entitlementInternalApi=Mockito.mock(EntitlementInternalApi.class);
      bind(EntitlementInternalApi.class).toInstance(entitlementInternalApi);
      try {
        Mockito.when(entitlementInternalApi.getBundleFromId(Mockito.<UUID>any(),Mockito.<InternalTenantContext>any())).thenReturn(bundle);
      }
 catch (      EntitlementUserApiException e) {
        Assert.fail(e.toString());
      }
    }
  }
);
  checker=i.getInstance(BlockingChecker.class);
}
