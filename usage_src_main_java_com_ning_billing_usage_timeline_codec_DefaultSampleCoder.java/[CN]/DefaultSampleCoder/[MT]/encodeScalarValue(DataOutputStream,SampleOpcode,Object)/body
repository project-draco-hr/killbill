{
  try {
    outputStream.write(opcode.getOpcodeIndex());
switch (opcode) {
case NULL:
case DOUBLE_ZERO:
case INT_ZERO:
      break;
case BYTE:
case BYTE_FOR_DOUBLE:
    outputStream.writeByte((Byte)value);
  break;
case SHORT:
case SHORT_FOR_DOUBLE:
case HALF_FLOAT_FOR_DOUBLE:
outputStream.writeShort((Short)value);
break;
case INT:
outputStream.writeInt((Integer)value);
break;
case LONG:
outputStream.writeLong((Long)value);
break;
case FLOAT:
case FLOAT_FOR_DOUBLE:
outputStream.writeFloat((Float)value);
break;
case DOUBLE:
outputStream.writeDouble((Double)value);
break;
case STRING:
final String s=(String)value;
final byte[] bytes=s.getBytes("UTF-8");
outputStream.writeShort(s.length());
outputStream.write(bytes,0,bytes.length);
break;
case BIGINT:
final String bs=value.toString();
if (bs.length() > Short.MAX_VALUE) {
throw new IllegalStateException(String.format("In DefaultSampleCoder.encodeScalarValue(), the string length of the BigInteger is %d; too large to be represented in a Short",bs.length()));
}
final byte[] bbytes=bs.getBytes("UTF-8");
outputStream.writeShort(bs.length());
outputStream.write(bbytes,0,bbytes.length);
break;
default :
final String err=String.format("In encodeScalarSample, opcode %s is unrecognized",opcode.name());
log.error(err);
throw new IllegalArgumentException(err);
}
}
 catch (IOException e) {
log.error(String.format("In encodeScalarValue, IOException encoding opcode %s and value %s",opcode.name(),String.valueOf(value)),e);
}
}
