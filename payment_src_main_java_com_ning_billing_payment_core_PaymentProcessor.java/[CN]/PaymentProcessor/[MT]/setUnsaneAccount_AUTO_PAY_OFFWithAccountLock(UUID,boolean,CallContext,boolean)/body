{
  final List<PaymentModelDao> payments=paymentDao.getPaymentsForAccount(accountId);
  final Collection<PaymentModelDao> badPayments=Collections2.filter(payments,new Predicate<PaymentModelDao>(){
    @Override public boolean apply(    PaymentModelDao input){
      return (input.getPaymentStatus() != PaymentStatus.SUCCESS && input.getPaymentStatus() != PaymentStatus.PAYMENT_FAILURE && input.getPaymentStatus() != PaymentStatus.AUTO_PAY_OFF);
    }
  }
);
  if (badPayments.size() > 0) {
    if (!isInstantPayment && !isAccountAutoPayOff) {
      JOINER.join(Collections2.transform(badPayments,new Function<PaymentModelDao,String>(){
        @Override public String apply(        PaymentModelDao input){
          return String.format("%s [%s]",input.getId(),input.getPaymentStatus());
        }
      }
));
      log.warn(String.format("Setting account %s into AUTO_PAY_OFF because of bad payments : %s",accountId,JOINER.toString()));
      try {
        tagUserApi.addTag(accountId,ObjectType.ACCOUNT,ControlTagType.AUTO_PAY_OFF.getId(),context);
      }
 catch (      TagApiException e) {
        log.error("Failed to add AUTO_PAY_OFF on account " + accountId,e);
        throw new PaymentApiException(ErrorCode.PAYMENT_INTERNAL_ERROR,"Failed to add AUTO_PAY_OFF on account " + accountId);
      }
    }
    return true;
  }
 else {
    return false;
  }
}
