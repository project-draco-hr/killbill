{
  List<PaymentAttemptModelDao> allAttempts=null;
  if (paymentConfig.isPaymentOff()) {
    paymentDao.updateStatusForPaymentWithAttempt(paymentInput.getId(),PaymentStatus.PAYMENT_SYSTEM_OFF,null,null,attemptInput.getId(),context);
    allAttempts=paymentDao.getAttemptsForPayment(paymentInput.getId(),context);
    return new DefaultPayment(paymentInput,null,allAttempts,Collections.<RefundModelDao>emptyList());
  }
  PaymentModelDao payment=null;
  BusInternalEvent event=null;
  PaymentStatus paymentStatus;
  final PaymentInfoPlugin paymentPluginInfo;
  try {
    paymentPluginInfo=plugin.processPayment(account.getId(),paymentInput.getId(),paymentInput.getPaymentMethodId(),attemptInput.getRequestedAmount(),account.getCurrency(),context.toCallContext());
switch (paymentPluginInfo.getStatus()) {
case PROCESSED:
      paymentStatus=PaymentStatus.SUCCESS;
    paymentDao.updateStatusForPaymentWithAttempt(paymentInput.getId(),paymentStatus,paymentPluginInfo.getGatewayErrorCode(),null,attemptInput.getId(),context);
  allAttempts=paymentDao.getAttemptsForPayment(paymentInput.getId(),context);
payment=paymentDao.getPayment(paymentInput.getId(),context);
invoiceApi.notifyOfPayment(invoice.getId(),payment.getAmount(),payment.getCurrency(),payment.getId(),payment.getEffectiveDate(),context);
event=new DefaultPaymentInfoEvent(account.getId(),invoice.getId(),payment.getId(),payment.getAmount(),payment.getPaymentNumber(),paymentStatus,context.getUserToken(),payment.getEffectiveDate(),context.getAccountRecordId(),context.getTenantRecordId());
break;
case ERROR:
allAttempts=paymentDao.getAttemptsForPayment(paymentInput.getId(),context);
if (!isInstantPayment) {
paymentStatus=scheduleRetryOnPaymentFailure(paymentInput.getId(),context);
}
 else {
paymentStatus=PaymentStatus.PAYMENT_FAILURE_ABORTED;
}
paymentDao.updateStatusForPaymentWithAttempt(paymentInput.getId(),paymentStatus,paymentPluginInfo.getGatewayErrorCode(),paymentPluginInfo.getGatewayError(),attemptInput.getId(),context);
log.info(String.format("Could not process payment for account %s, invoice %s, error = %s",account.getId(),invoice.getId(),paymentPluginInfo.getGatewayError()));
event=new DefaultPaymentErrorEvent(account.getId(),invoice.getId(),paymentInput.getId(),paymentPluginInfo.getGatewayError(),context.getUserToken(),context.getAccountRecordId(),context.getTenantRecordId());
throw new PaymentApiException(ErrorCode.PAYMENT_CREATE_PAYMENT,account.getId(),paymentPluginInfo.getGatewayError());
default :
final String formatError=String.format("Plugin return status %s for payment %s",paymentPluginInfo.getStatus(),paymentInput.getId());
throw new PaymentPluginApiException("",formatError);
}
}
 catch (PaymentPluginApiException e) {
paymentStatus=isInstantPayment ? PaymentStatus.PAYMENT_FAILURE_ABORTED : scheduleRetryOnPluginFailure(paymentInput.getId(),context);
paymentDao.updateStatusForPaymentWithAttempt(paymentInput.getId(),paymentStatus,null,e.getMessage(),attemptInput.getId(),context);
throw new PaymentApiException(ErrorCode.PAYMENT_CREATE_PAYMENT,account.getId(),e.toString());
}
catch (InvoiceApiException e) {
throw new PaymentApiException(ErrorCode.INVOICE_NOT_FOUND,invoice.getId(),e.toString());
}
 finally {
if (event != null) {
postPaymentEvent(event,account.getId(),context);
}
}
return new DefaultPayment(payment,paymentPluginInfo,allAttempts,Collections.<RefundModelDao>emptyList());
}
