{
  List<PaymentAttemptModelDao> allAttempts=null;
  if (paymentConfig.isPaymentOff()) {
    paymentDao.updateStatusAndEffectiveDateForPaymentWithAttempt(paymentInput.getId(),PaymentStatus.PAYMENT_SYSTEM_OFF,clock.getUTCNow(),attemptInput.getId(),null,null,context);
    allAttempts=paymentDao.getAttemptsForPayment(paymentInput.getId(),context);
    return new DefaultPayment(paymentInput,null,allAttempts,Collections.<RefundModelDao>emptyList());
  }
  PaymentModelDao payment=null;
  BusInternalEvent event=null;
  PaymentStatus paymentStatus;
  final PaymentInfoPlugin paymentPluginInfo;
  try {
    try {
      paymentPluginInfo=plugin.processPayment(account.getId(),paymentInput.getId(),paymentInput.getPaymentMethodId(),attemptInput.getRequestedAmount(),account.getCurrency(),context.toCallContext());
    }
 catch (    RuntimeException e) {
      final String formatError=String.format("Plugin threw RuntimeException for payment %s",paymentInput.getId());
      throw new PaymentPluginApiException(formatError,e);
    }
switch (paymentPluginInfo.getStatus()) {
case PROCESSED:
      paymentStatus=PaymentStatus.SUCCESS;
    paymentDao.updateStatusAndEffectiveDateForPaymentWithAttempt(paymentInput.getId(),paymentStatus,clock.getUTCNow(),attemptInput.getId(),paymentPluginInfo.getGatewayErrorCode(),null,context);
  allAttempts=paymentDao.getAttemptsForPayment(paymentInput.getId(),context);
payment=paymentDao.getPayment(paymentInput.getId(),context);
invoiceApi.notifyOfPayment(invoice.getId(),payment.getAmount(),payment.getCurrency(),payment.getId(),payment.getEffectiveDate(),context);
event=new DefaultPaymentInfoEvent(account.getId(),invoice.getId(),payment.getId(),payment.getAmount(),payment.getPaymentNumber(),paymentStatus,payment.getEffectiveDate(),context.getAccountRecordId(),context.getTenantRecordId(),context.getUserToken());
break;
case ERROR:
allAttempts=paymentDao.getAttemptsForPayment(paymentInput.getId(),context);
if (!isInstantPayment) {
paymentStatus=scheduleRetryOnPaymentFailure(paymentInput.getId(),context);
}
 else {
paymentStatus=PaymentStatus.PAYMENT_FAILURE_ABORTED;
}
paymentDao.updateStatusAndEffectiveDateForPaymentWithAttempt(paymentInput.getId(),paymentStatus,clock.getUTCNow(),attemptInput.getId(),paymentPluginInfo.getGatewayErrorCode(),paymentPluginInfo.getGatewayError(),context);
log.info(String.format("Could not process payment for account %s, invoice %s, error = %s",account.getId(),invoice.getId(),paymentPluginInfo.getGatewayError()));
event=new DefaultPaymentErrorEvent(account.getId(),invoice.getId(),paymentInput.getId(),paymentPluginInfo.getGatewayError(),context.getAccountRecordId(),context.getTenantRecordId(),context.getUserToken());
throw new PaymentApiException(ErrorCode.PAYMENT_CREATE_PAYMENT,account.getId(),paymentPluginInfo.getGatewayError());
default :
final String formatError=String.format("Plugin return status %s for payment %s",paymentPluginInfo.getStatus(),paymentInput.getId());
throw new PaymentPluginApiException("",formatError);
}
}
 catch (PaymentPluginApiException e) {
paymentStatus=isInstantPayment ? PaymentStatus.PAYMENT_FAILURE_ABORTED : scheduleRetryOnPluginFailure(paymentInput.getId(),context);
paymentDao.updateStatusAndEffectiveDateForPaymentWithAttempt(paymentInput.getId(),paymentStatus,clock.getUTCNow(),attemptInput.getId(),null,e.getMessage(),context);
event=new DefaultPaymentPluginErrorEvent(account.getId(),invoice.getId(),paymentInput.getId(),e.getMessage(),context.getAccountRecordId(),context.getTenantRecordId(),context.getUserToken());
throw new PaymentApiException(ErrorCode.PAYMENT_CREATE_PAYMENT,account.getId(),e.toString());
}
catch (InvoiceApiException e) {
throw new PaymentApiException(ErrorCode.INVOICE_NOT_FOUND,invoice.getId(),e.toString());
}
 finally {
if (event != null) {
postPaymentEvent(event,account.getId(),context);
}
}
return new DefaultPayment(payment,paymentPluginInfo,allAttempts,Collections.<RefundModelDao>emptyList());
}
