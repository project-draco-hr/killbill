{
  try {
    voidPluginDispatcher.dispatchWithAccountLock(new CallableWithAccountLock<Void>(locker,account.getExternalKey(),new WithAccountLockCallback<Void>(){
      @Override public Void doOperation() throws PaymentApiException {
        final List<PaymentModelDao> payments=paymentDao.getPaymentsForAccount(account.getId());
        final Collection<PaymentModelDao> paymentsToBeCompleted=Collections2.filter(payments,new Predicate<PaymentModelDao>(){
          @Override public boolean apply(          final PaymentModelDao in){
            return (in.getPaymentStatus() == PaymentStatus.AUTO_PAY_OFF || in.getPaymentStatus() == PaymentStatus.PAYMENT_FAILURE || in.getPaymentStatus() == PaymentStatus.PLUGIN_FAILURE);
          }
        }
);
        for (        PaymentModelDao cur : paymentsToBeCompleted) {
switch (cur.getPaymentStatus()) {
case AUTO_PAY_OFF:
            autoPayoffRetryService.scheduleRetry(cur.getId(),clock.getUTCNow());
          break;
case PAYMENT_FAILURE:
        scheduleRetryOnPaymentFailure(cur.getId());
      break;
case PLUGIN_FAILURE:
    scheduleRetryOnPluginFailure(cur.getId());
  break;
default :
throw new RuntimeException("Unexpected case " + cur.getPaymentStatus());
}
}
return null;
}
}
));
}
 catch (TimeoutException e) {
throw new PaymentApiException(ErrorCode.UNEXPECTED_ERROR,"Unexpected timeout for payment creation (AUTO_PAY_OFF)");
}
}
