{
  log.info("Beginning test with BCD of " + billingDay);
  final Account account=createAccountWithPaymentMethod(getAccountData(billingDay));
  final UUID accountId=account.getId();
  clock.setDeltaFromReality(initialCreationDate.getMillis() - clock.getUTCNow().getMillis());
  final SubscriptionBundle bundle=entitlementUserApi.createBundleForAccount(account.getId(),"whatever",context);
  final String productName="Shotgun";
  final BillingPeriod term=BillingPeriod.MONTHLY;
  final String planSetName=PriceListSet.DEFAULT_PRICELIST_NAME;
  busHandler.pushExpectedEvent(NextEvent.CREATE);
  busHandler.pushExpectedEvent(NextEvent.INVOICE);
  SubscriptionData subscription=subscriptionDataFromSubscription(entitlementUserApi.createSubscription(bundle.getId(),new PlanPhaseSpecifier(productName,ProductCategory.BASE,term,planSetName,null),null,context));
  assertNotNull(subscription);
  assertTrue(busHandler.isCompleted(DELAY));
  DateTime startDate=subscription.getCurrentPhaseStart();
  BigDecimal rate=subscription.getCurrentPhase().getFixedPrice().getPrice(Currency.USD);
  int invoiceItemCount=1;
  verifyTestResult(accountId,subscription.getId(),startDate,null,rate,clock.getUTCNow(),invoiceItemCount);
  busHandler.pushExpectedEvent(NextEvent.CHANGE);
  busHandler.pushExpectedEvent(NextEvent.INVOICE);
  BillingPeriod newTerm=BillingPeriod.MONTHLY;
  String newPlanSetName=PriceListSet.DEFAULT_PRICELIST_NAME;
  String newProductName="Assault-Rifle";
  subscription.changePlan(newProductName,newTerm,newPlanSetName,clock.getUTCNow(),context);
  assertTrue(busHandler.isCompleted(DELAY));
  startDate=subscription.getCurrentPhaseStart();
  invoiceItemCount=2;
  verifyTestResult(accountId,subscription.getId(),startDate,null,rate,clock.getUTCNow(),invoiceItemCount);
  for (  final DateTime dateTimeToSet : expectedStates.keySet()) {
    for (    final NextEvent expectedEvent : expectedStates.get(dateTimeToSet)) {
      busHandler.pushExpectedEvent(expectedEvent);
    }
    clock.setTime(dateTimeToSet);
    assertTrue(busHandler.isCompleted(DELAY));
  }
  startDate=subscription.getCurrentPhaseStart();
  rate=subscription.getCurrentPhase().getRecurringPrice().getPrice(Currency.USD);
  BigDecimal price;
  final DateTime chargeThroughDate;
switch (billingDay) {
case 1:
    price=THIRTY.divide(THIRTY_ONE,2 * NUMBER_OF_DECIMALS,ROUNDING_METHOD).multiply(rate).setScale(NUMBER_OF_DECIMALS,ROUNDING_METHOD);
  chargeThroughDate=startDate.plusMonths(1).toMutableDateTime().dayOfMonth().set(billingDay).toDateTime();
invoiceItemCount+=1;
verifyTestResult(accountId,subscription.getId(),startDate,chargeThroughDate,price,chargeThroughDate,invoiceItemCount);
break;
case 2:
price=rate;
chargeThroughDate=startDate.plusMonths(1);
invoiceItemCount+=1;
verifyTestResult(accountId,subscription.getId(),startDate,chargeThroughDate,price,chargeThroughDate,invoiceItemCount);
break;
case 3:
price=ONE.divide(TWENTY_NINE,2 * NUMBER_OF_DECIMALS,ROUNDING_METHOD).multiply(rate).setScale(NUMBER_OF_DECIMALS,ROUNDING_METHOD);
final DateTime firstEndDate=startDate.plusDays(1);
chargeThroughDate=firstEndDate.plusMonths(1);
invoiceItemCount+=2;
verifyTestResult(accountId,subscription.getId(),startDate,firstEndDate,price,chargeThroughDate,invoiceItemCount);
verifyTestResult(accountId,subscription.getId(),firstEndDate,chargeThroughDate,rate,chargeThroughDate,invoiceItemCount);
break;
case 31:
chargeThroughDate=startDate.toMutableDateTime().dayOfMonth().set(31).toDateTime();
price=TWENTY_NINE.divide(THIRTY_ONE,2 * NUMBER_OF_DECIMALS,ROUNDING_METHOD).multiply(rate).setScale(NUMBER_OF_DECIMALS,ROUNDING_METHOD);
invoiceItemCount+=1;
verifyTestResult(accountId,subscription.getId(),startDate,chargeThroughDate,price,chargeThroughDate,invoiceItemCount);
break;
default :
throw new UnsupportedOperationException();
}
newTerm=BillingPeriod.MONTHLY;
newPlanSetName=PriceListSet.DEFAULT_PRICELIST_NAME;
newProductName="Pistol";
subscription=subscriptionDataFromSubscription(entitlementUserApi.getSubscriptionFromId(subscription.getId()));
subscription.changePlan(newProductName,newTerm,newPlanSetName,clock.getUTCNow(),context);
busHandler.pushExpectedEvent(NextEvent.CHANGE);
busHandler.pushExpectedEvent(NextEvent.INVOICE);
busHandler.pushExpectedEvent(NextEvent.PAYMENT);
clock.addDeltaFromReality(AT_LEAST_ONE_MONTH_MS);
assertTrue(busHandler.isCompleted(DELAY));
startDate=chargeThroughDate;
DateTime endDate=chargeThroughDate.plusMonths(1);
price=subscription.getCurrentPhase().getRecurringPrice().getPrice(Currency.USD);
invoiceItemCount+=1;
verifyTestResult(accountId,subscription.getId(),startDate,endDate,price,endDate,invoiceItemCount);
int maxCycles=3;
do {
busHandler.pushExpectedEvent(NextEvent.INVOICE);
busHandler.pushExpectedEvent(NextEvent.PAYMENT);
clock.addDeltaFromReality(AT_LEAST_ONE_MONTH_MS + 1000);
assertTrue(busHandler.isCompleted(DELAY));
startDate=endDate;
endDate=startDate.plusMonths(1);
if (endDate.dayOfMonth().get() != billingDay) {
final int maximumDay=endDate.dayOfMonth().getMaximumValue();
final int newDay=(maximumDay < billingDay) ? maximumDay : billingDay;
endDate=endDate.toMutableDateTime().dayOfMonth().set(newDay).toDateTime();
}
invoiceItemCount+=1;
verifyTestResult(accountId,subscription.getId(),startDate,endDate,price,endDate,invoiceItemCount);
}
 while (maxCycles-- > 0);
subscription=subscriptionDataFromSubscription(entitlementUserApi.getSubscriptionFromId(subscription.getId()));
subscription.cancel(clock.getUTCNow(),false,context);
busHandler.pushExpectedEvent(NextEvent.CANCEL);
final Interval it=new Interval(clock.getUTCNow(),endDate);
clock.addDeltaFromReality(it.toDurationMillis());
assertTrue(busHandler.isCompleted(DELAY));
busHandler.reset();
clock.addDeltaFromReality(AT_LEAST_ONE_MONTH_MS + 1000);
assertTrue(busHandler.isCompleted(DELAY));
subscription=subscriptionDataFromSubscription(entitlementUserApi.getSubscriptionFromId(subscription.getId()));
final DateTime lastCtd=subscription.getChargedThroughDate();
assertNotNull(lastCtd);
log.info("Checking CTD: " + lastCtd.toString() + "; clock is "+ clock.getUTCNow().toString());
assertTrue(lastCtd.isBefore(clock.getUTCNow()));
Thread.sleep(DELAY);
assertListenerStatus();
log.info("TEST PASSED !");
}
