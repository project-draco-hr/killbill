{
  log.info("Beginning test with BCD of " + billingDay);
  final Account account=createAccountWithPaymentMethod(getAccountData(billingDay));
  final UUID accountId=account.getId();
  clock.setDeltaFromReality(initialCreationDate.getMillis() - clock.getUTCNow().getMillis());
  final SubscriptionBundle bundle=entitlementUserApi.createBundleForAccount(account.getId(),"whatever",context);
  SubscriptionData subscription=subscriptionDataFromSubscription(createSubscriptionAndCheckForCompletion(bundle.getId(),"Shotgun",ProductCategory.BASE,BillingPeriod.MONTHLY,NextEvent.CREATE,NextEvent.INVOICE));
  invoiceChecker.checkInvoice(account.getId(),1,new ExpectedItemCheck(initialCreationDate.toLocalDate(),null,InvoiceItemType.FIXED,new BigDecimal("0")));
  DateTime startDate=subscription.getCurrentPhaseStart();
  BigDecimal rate=subscription.getCurrentPhase().getFixedPrice().getPrice(Currency.USD);
  int invoiceItemCount=1;
  verifyTestResult(accountId,subscription.getId(),startDate,null,rate,clock.getUTCNow(),invoiceItemCount);
  subscription=subscriptionDataFromSubscription(changeSubscriptionAndCheckForCompletion(subscription,"Assault-Rifle",BillingPeriod.MONTHLY,NextEvent.CHANGE,NextEvent.INVOICE));
  startDate=subscription.getCurrentPhaseStart();
  invoiceItemCount=2;
  verifyTestResult(accountId,subscription.getId(),startDate,null,rate,clock.getUTCNow(),invoiceItemCount);
  for (  final DateTime dateTimeToSet : expectedStates.keySet()) {
    for (    final NextEvent expectedEvent : expectedStates.get(dateTimeToSet)) {
      busHandler.pushExpectedEvent(expectedEvent);
    }
    clock.setTime(dateTimeToSet);
    assertTrue(busHandler.isCompleted(DELAY));
  }
  startDate=subscription.getCurrentPhaseStart();
  rate=subscription.getCurrentPhase().getRecurringPrice().getPrice(Currency.USD);
  BigDecimal price;
  final DateTime chargeThroughDate;
switch (billingDay) {
case 1:
    price=THIRTY.divide(THIRTY_ONE,2 * NUMBER_OF_DECIMALS,ROUNDING_METHOD).multiply(rate).setScale(NUMBER_OF_DECIMALS,ROUNDING_METHOD);
  chargeThroughDate=startDate.plusMonths(1).toMutableDateTime().dayOfMonth().set(billingDay).toDateTime();
invoiceItemCount+=1;
verifyTestResult(accountId,subscription.getId(),startDate,chargeThroughDate,price,chargeThroughDate,invoiceItemCount);
break;
case 2:
price=rate;
chargeThroughDate=startDate.plusMonths(1);
invoiceItemCount+=1;
verifyTestResult(accountId,subscription.getId(),startDate,chargeThroughDate,price,chargeThroughDate,invoiceItemCount);
break;
case 3:
price=ONE.divide(TWENTY_NINE,2 * NUMBER_OF_DECIMALS,ROUNDING_METHOD).multiply(rate).setScale(NUMBER_OF_DECIMALS,ROUNDING_METHOD);
final DateTime firstEndDate=startDate.plusDays(1);
chargeThroughDate=firstEndDate.plusMonths(1);
invoiceItemCount+=2;
verifyTestResult(accountId,subscription.getId(),startDate,firstEndDate,price,chargeThroughDate,invoiceItemCount);
verifyTestResult(accountId,subscription.getId(),firstEndDate,chargeThroughDate,rate,chargeThroughDate,invoiceItemCount);
break;
case 31:
chargeThroughDate=startDate.toMutableDateTime().dayOfMonth().set(31).toDateTime();
price=TWENTY_NINE.divide(THIRTY_ONE,2 * NUMBER_OF_DECIMALS,ROUNDING_METHOD).multiply(rate).setScale(NUMBER_OF_DECIMALS,ROUNDING_METHOD);
invoiceItemCount+=1;
verifyTestResult(accountId,subscription.getId(),startDate,chargeThroughDate,price,chargeThroughDate,invoiceItemCount);
break;
default :
throw new UnsupportedOperationException();
}
subscription=subscriptionDataFromSubscription(changeSubscriptionAndCheckForCompletion(subscription,"Pistol",BillingPeriod.MONTHLY));
addDaysAndCheckForCompletion(32,NextEvent.CHANGE,NextEvent.INVOICE,NextEvent.PAYMENT);
startDate=chargeThroughDate;
DateTime realChargeThroughDate=entitlementUserApi.getSubscriptionFromId(subscription.getId()).getChargedThroughDate();
DateTime endDate=realChargeThroughDate;
price=subscription.getCurrentPhase().getRecurringPrice().getPrice(Currency.USD);
invoiceItemCount+=1;
verifyTestResult(accountId,subscription.getId(),startDate,endDate,price,endDate,invoiceItemCount);
int maxCycles=3;
do {
busHandler.pushExpectedEvent(NextEvent.INVOICE);
busHandler.pushExpectedEvent(NextEvent.PAYMENT);
clock.addDeltaFromReality(AT_LEAST_ONE_MONTH_MS + 1000);
assertTrue(busHandler.isCompleted(DELAY));
startDate=endDate;
endDate=startDate.plusMonths(1);
if (endDate.dayOfMonth().get() != billingDay) {
final int maximumDay=endDate.dayOfMonth().getMaximumValue();
final int newDay=(maximumDay < billingDay) ? maximumDay : billingDay;
endDate=endDate.toMutableDateTime().dayOfMonth().set(newDay).toDateTime();
}
invoiceItemCount+=1;
verifyTestResult(accountId,subscription.getId(),startDate,endDate,price,endDate,invoiceItemCount);
}
 while (maxCycles-- > 0);
subscription=subscriptionDataFromSubscription(cancelSubscriptionAndCheckForCompletion(subscription,clock.getUTCNow()));
realChargeThroughDate=entitlementUserApi.getSubscriptionFromId(subscription.getId()).getChargedThroughDate();
final Interval it=new Interval(clock.getUTCNow(),realChargeThroughDate.plusSeconds(5));
addDaysAndCheckForCompletion((int)it.toDuration().getStandardDays(),NextEvent.CANCEL);
addDaysAndCheckForCompletion(32);
subscription=subscriptionDataFromSubscription(entitlementUserApi.getSubscriptionFromId(subscription.getId()));
final DateTime lastCtd=subscription.getChargedThroughDate();
assertNotNull(lastCtd);
log.info("Checking CTD: " + lastCtd.toString() + "; clock is "+ clock.getUTCNow().toString());
assertTrue(lastCtd.isBefore(clock.getUTCNow()));
log.info("TEST PASSED !");
}
