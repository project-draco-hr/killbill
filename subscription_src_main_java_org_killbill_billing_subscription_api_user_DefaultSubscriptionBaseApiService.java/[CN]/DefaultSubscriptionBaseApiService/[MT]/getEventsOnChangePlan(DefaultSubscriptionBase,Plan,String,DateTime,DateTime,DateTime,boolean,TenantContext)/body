{
  final TimedPhase currentTimedPhase=planAligner.getCurrentTimedPhaseOnChange(subscription,newPlan,newPriceList,requestedDate,effectiveDate);
  final SubscriptionBaseEvent changeEvent=new ApiEventChange(new ApiEventBuilder().setSubscriptionId(subscription.getId()).setEventPlan(newPlan.getName()).setEventPlanPhase(currentTimedPhase.getPhase().getName()).setEventPriceList(newPriceList).setActiveVersion(subscription.getActiveVersion()).setProcessedDate(processedDate).setEffectiveDate(effectiveDate).setRequestedDate(requestedDate).setFromDisk(true));
  final TimedPhase nextTimedPhase=planAligner.getNextTimedPhaseOnChange(subscription,newPlan,newPriceList,processedDate,effectiveDate);
  final PhaseEvent nextPhaseEvent=(nextTimedPhase != null) ? PhaseEventData.createNextPhaseEvent(subscription.getId(),subscription.getActiveVersion(),nextTimedPhase.getPhase().getName(),processedDate,nextTimedPhase.getStartPhase()) : null;
  final List<SubscriptionBaseEvent> changeEvents=new ArrayList<SubscriptionBaseEvent>();
  changeEvents.add(changeEvent);
  if (nextPhaseEvent != null && !nextPhaseEvent.getEffectiveDate().equals(changeEvent.getEffectiveDate())) {
    changeEvents.add(nextPhaseEvent);
  }
  if (subscription.getCategory() == ProductCategory.BASE && addCancellationAddOnForEventsIfRequired) {
    final Product currentBaseProduct=changeEvent.getEffectiveDate().compareTo(clock.getUTCNow()) <= 0 ? newPlan.getProduct() : subscription.getCurrentPlan().getProduct();
    addCancellationAddOnForEventsIfRequired(changeEvents,currentBaseProduct,subscription.getBundleId(),requestedDate,effectiveDate,processedDate,context);
  }
  return changeEvents;
}
