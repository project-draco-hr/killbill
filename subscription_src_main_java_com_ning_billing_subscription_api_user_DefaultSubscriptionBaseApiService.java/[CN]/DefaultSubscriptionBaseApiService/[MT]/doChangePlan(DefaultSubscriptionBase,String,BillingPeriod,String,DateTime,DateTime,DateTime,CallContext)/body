{
  final Plan newPlan=catalogService.getFullCatalog().findPlan(newProductName,newBillingPeriod,newPriceList,effectiveDate,subscription.getStartDate());
  final TimedPhase currentTimedPhase=planAligner.getCurrentTimedPhaseOnChange(subscription,newPlan,newPriceList,requestedDate,effectiveDate);
  final SubscriptionBaseEvent changeEvent=new ApiEventChange(new ApiEventBuilder().setSubscriptionId(subscription.getId()).setEventPlan(newPlan.getName()).setEventPlanPhase(currentTimedPhase.getPhase().getName()).setEventPriceList(newPriceList).setActiveVersion(subscription.getActiveVersion()).setProcessedDate(now).setEffectiveDate(effectiveDate).setRequestedDate(requestedDate).setFromDisk(true));
  final TimedPhase nextTimedPhase=planAligner.getNextTimedPhaseOnChange(subscription,newPlan,newPriceList,requestedDate,effectiveDate);
  final PhaseEvent nextPhaseEvent=(nextTimedPhase != null) ? PhaseEventData.createNextPhaseEvent(nextTimedPhase.getPhase().getName(),subscription,now,nextTimedPhase.getStartPhase()) : null;
  final List<SubscriptionBaseEvent> changeEvents=new ArrayList<SubscriptionBaseEvent>();
  if (nextPhaseEvent != null && !nextPhaseEvent.getEffectiveDate().equals(changeEvent.getEffectiveDate())) {
    changeEvents.add(nextPhaseEvent);
  }
  changeEvents.add(changeEvent);
  final InternalCallContext internalCallContext=createCallContextFromBundleId(subscription.getBundleId(),context);
  dao.changePlan(subscription,changeEvents,internalCallContext);
  subscription.rebuildTransitions(dao.getEventsForSubscription(subscription.getId(),internalCallContext),catalogService.getFullCatalog());
  cancelAddOnsIfRequired(subscription,effectiveDate,internalCallContext);
  final boolean isChangeImmediate=subscription.getCurrentPlan().getProduct().getName().equals(newProductName) && subscription.getCurrentPlan().getBillingPeriod() == newBillingPeriod;
  return effectiveDate;
}
