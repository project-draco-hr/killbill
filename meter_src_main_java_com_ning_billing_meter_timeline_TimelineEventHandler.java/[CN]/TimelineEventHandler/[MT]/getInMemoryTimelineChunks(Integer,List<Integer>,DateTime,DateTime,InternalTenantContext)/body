{
  getInMemoryChunksCallCount.incrementAndGet();
  final SourceAccumulatorsAndUpdateDate sourceAccumulatorsAndDate=accumulators.get(sourceId);
  if (sourceAccumulatorsAndDate == null) {
    return ImmutableList.of();
  }
  final List<TimelineChunk> samplesBySourceName=new ArrayList<TimelineChunk>();
  for (  final TimelineSourceEventAccumulator accumulator : sourceAccumulatorsAndDate.getCategoryAccumulators().values()) {
    if ((filterStartTime != null && accumulator.getEndTime().isBefore(filterStartTime)) || (filterEndTime != null && accumulator.getStartTime().isAfter(filterEndTime))) {
      continue;
    }
    samplesBySourceName.addAll(accumulator.getInMemoryTimelineChunks(metricIds));
  }
  inMemoryChunksReturnedCount.addAndGet(samplesBySourceName.size());
  Collections.sort(samplesBySourceName,CHUNK_COMPARATOR);
  return samplesBySourceName;
}
