{
  getInMemoryChunksCallCount.incrementAndGet();
  final SourceAccumulatorsAndUpdateDate sourceAccumulatorsAndDate=accumulators.get(sourceId);
  if (sourceAccumulatorsAndDate == null) {
    return ImmutableList.of();
  }
  final List<TimelineChunk> samplesBySourceName=new ArrayList<TimelineChunk>();
  for (  final TimelineSourceEventAccumulator accumulator : sourceAccumulatorsAndDate.getCategoryAccumulators().values()) {
    for (    final TimelineChunk chunk : accumulator.getPendingTimelineChunks()) {
      if ((filterStartTime != null && chunk.getEndTime().isBefore(filterStartTime)) || (filterEndTime != null && chunk.getStartTime().isAfter(filterEndTime)) || !metricIds.contains(chunk.getMetricId())) {
        continue;
      }
 else {
        samplesBySourceName.add(chunk);
      }
    }
    final List<DateTime> accumulatorTimes=accumulator.getTimes();
    if (accumulatorTimes.size() == 0) {
      continue;
    }
    final DateTime accumulatorStartTime=accumulator.getStartTime();
    final DateTime accumulatorEndTime=accumulator.getEndTime();
    if ((filterStartTime != null && accumulatorEndTime.isBefore(filterStartTime)) || (filterEndTime != null && accumulatorStartTime.isAfter(filterEndTime))) {
      continue;
    }
    final byte[] timeBytes=timelineCoder.compressDateTimes(accumulatorTimes);
    for (    final TimelineChunkAccumulator chunkAccumulator : accumulator.getTimelines().values()) {
      if (metricIds.contains(chunkAccumulator.getMetricId())) {
        accumulatorDeepCopyCount.incrementAndGet();
        final TimelineChunkAccumulator chunkAccumulatorCopy=chunkAccumulator.deepCopy();
        final TimelineChunk timelineChunk=chunkAccumulatorCopy.extractTimelineChunkAndReset(accumulatorStartTime,accumulatorEndTime,timeBytes);
        samplesBySourceName.add(timelineChunk);
      }
    }
  }
  inMemoryChunksReturnedCount.addAndGet(samplesBySourceName.size());
  Collections.sort(samplesBySourceName,CHUNK_COMPARATOR);
  return samplesBySourceName;
}
