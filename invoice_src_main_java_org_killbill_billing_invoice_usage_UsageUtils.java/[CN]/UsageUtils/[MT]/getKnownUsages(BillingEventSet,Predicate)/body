{
  final Iterable<Usage> usages=Iterables.concat(Iterables.transform(billingEvents,new Function<BillingEvent,List<Usage>>(){
    @Override public List<Usage> apply(    final BillingEvent input){
      return input.getUsages();
    }
  }
));
  final Iterable<Usage> filteredUsages=(filter != null) ? Iterables.filter(usages,filter) : usages;
  final Map<String,Usage> result=(filteredUsages.iterator().hasNext()) ? new HashMap<String,Usage>() : Collections.<String,Usage>emptyMap();
  while (filteredUsages.iterator().hasNext()) {
    final Usage next=filteredUsages.iterator().next();
    result.put(next.getName(),next);
  }
  return result;
}
