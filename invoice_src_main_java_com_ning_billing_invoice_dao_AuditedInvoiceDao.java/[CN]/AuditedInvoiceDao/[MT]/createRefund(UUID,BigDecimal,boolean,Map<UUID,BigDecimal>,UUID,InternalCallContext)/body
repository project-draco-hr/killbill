{
  final boolean isInvoiceItemAdjusted=isInvoiceAdjusted && invoiceItemIdsWithNullAmounts.size() > 0;
  return transactionalSqlDao.execute(new EntitySqlDaoTransactionWrapper<InvoicePayment>(){
    @Override public InvoicePayment inTransaction(    final EntitySqlDaoWrapperFactory<EntitySqlDao> entitySqlDaoWrapperFactory) throws Exception {
      final InvoicePaymentSqlDao transactional=entitySqlDaoWrapperFactory.become(InvoicePaymentSqlDao.class);
      final InvoiceSqlDao transInvoiceDao=entitySqlDaoWrapperFactory.become(InvoiceSqlDao.class);
      final InvoicePayment payment=transactional.getByPaymentId(paymentId.toString(),context);
      if (payment == null) {
        throw new InvoiceApiException(ErrorCode.INVOICE_PAYMENT_BY_ATTEMPT_NOT_FOUND,paymentId);
      }
      final Map<UUID,BigDecimal> invoiceItemIdsWithAmounts=computeItemAdjustments(payment.getInvoiceId().toString(),entitySqlDaoWrapperFactory,invoiceItemIdsWithNullAmounts,context);
      final BigDecimal requestedPositiveAmount=computePositiveRefundAmount(payment,requestedRefundAmount,invoiceItemIdsWithAmounts);
      final InvoicePayment existingRefund=transactional.getPaymentsForCookieId(paymentCookieId.toString(),context);
      if (existingRefund != null) {
        return existingRefund;
      }
      final InvoicePayment refund=new DefaultInvoicePayment(UUID.randomUUID(),InvoicePaymentType.REFUND,paymentId,payment.getInvoiceId(),context.getCreatedDate(),requestedPositiveAmount.negate(),payment.getCurrency(),paymentCookieId,payment.getId());
      transactional.create(refund,context);
      final Invoice invoice=transInvoiceDao.getById(payment.getInvoiceId().toString(),context);
      if (invoice != null) {
        populateChildren(invoice,entitySqlDaoWrapperFactory,context);
      }
 else {
        throw new IllegalStateException("Invoice shouldn't be null for payment " + payment.getId());
      }
      final BigDecimal invoiceBalanceAfterRefund=invoice.getBalance();
      final InvoiceItemSqlDao transInvoiceItemDao=entitySqlDaoWrapperFactory.become(InvoiceItemSqlDao.class);
      if (isInvoiceAdjusted && !isInvoiceItemAdjusted) {
        final BigDecimal maxBalanceToAdjust=(invoiceBalanceAfterRefund.compareTo(BigDecimal.ZERO) <= 0) ? BigDecimal.ZERO : invoiceBalanceAfterRefund;
        final BigDecimal requestedPositiveAmountToAdjust=requestedPositiveAmount.compareTo(maxBalanceToAdjust) > 0 ? maxBalanceToAdjust : requestedPositiveAmount;
        if (requestedPositiveAmountToAdjust.compareTo(BigDecimal.ZERO) > 0) {
          final InvoiceItem adjItem=new RefundAdjInvoiceItem(invoice.getId(),invoice.getAccountId(),context.getCreatedDate().toLocalDate(),requestedPositiveAmountToAdjust.negate(),invoice.getCurrency());
          transInvoiceItemDao.create(adjItem,context);
        }
      }
 else       if (isInvoiceAdjusted) {
        for (        final UUID invoiceItemId : invoiceItemIdsWithAmounts.keySet()) {
          final BigDecimal adjAmount=invoiceItemIdsWithAmounts.get(invoiceItemId);
          final InvoiceItem item=createAdjustmentItem(entitySqlDaoWrapperFactory,invoice.getId(),invoiceItemId,adjAmount,invoice.getCurrency(),context.getCreatedDate().toLocalDate(),context);
          transInvoiceItemDao.create(item,context);
        }
      }
      notifyBusOfInvoiceAdjustment(entitySqlDaoWrapperFactory,invoice.getId(),invoice.getAccountId(),context.getUserToken(),context);
      return refund;
    }
  }
);
}
