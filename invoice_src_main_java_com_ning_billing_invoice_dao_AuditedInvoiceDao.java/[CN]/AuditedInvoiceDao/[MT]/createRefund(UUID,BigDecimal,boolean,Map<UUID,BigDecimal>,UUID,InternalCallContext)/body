{
  final boolean isInvoiceItemAdjusted=isInvoiceAdjusted && invoiceItemIdsWithNullAmounts.size() > 0;
  return invoicePaymentSqlDao.inTransaction(new Transaction<InvoicePayment,InvoicePaymentSqlDao>(){
    @Override public InvoicePayment inTransaction(    final InvoicePaymentSqlDao transactional,    final TransactionStatus status) throws Exception {
      final List<EntityAudit> audits=new ArrayList<EntityAudit>();
      final InvoiceSqlDao transInvoiceDao=transactional.become(InvoiceSqlDao.class);
      final InvoicePayment payment=transactional.getByPaymentId(paymentId.toString(),context);
      if (payment == null) {
        throw new InvoiceApiException(ErrorCode.INVOICE_PAYMENT_BY_ATTEMPT_NOT_FOUND,paymentId);
      }
      final Map<UUID,BigDecimal> invoiceItemIdsWithAmounts=computeItemAdjustments(payment.getInvoiceId().toString(),transInvoiceDao,invoiceItemIdsWithNullAmounts,context);
      final BigDecimal requestedPositiveAmount=computePositiveRefundAmount(payment,requestedRefundAmount,invoiceItemIdsWithAmounts);
      final InvoicePayment existingRefund=transactional.getPaymentsForCookieId(paymentCookieId.toString(),context);
      if (existingRefund != null) {
        return existingRefund;
      }
      final InvoicePayment refund=new DefaultInvoicePayment(UUID.randomUUID(),InvoicePaymentType.REFUND,paymentId,payment.getInvoiceId(),context.getCreatedDate(),requestedPositiveAmount.negate(),payment.getCurrency(),paymentCookieId,payment.getId());
      transactional.create(refund,context);
      final Long refundRecordId=transactional.getRecordId(refund.getId().toString(),context);
      audits.add(new EntityAudit(TableName.REFUNDS,refundRecordId,ChangeType.INSERT));
      final Invoice invoice=transInvoiceDao.getById(payment.getInvoiceId().toString(),context);
      if (invoice != null) {
        populateChildren(invoice,transInvoiceDao,context);
      }
 else {
        throw new IllegalStateException("Invoice shouldn't be null for payment " + payment.getId());
      }
      final BigDecimal invoiceBalanceAfterRefund=invoice.getBalance();
      final InvoiceItemSqlDao transInvoiceItemDao=transInvoiceDao.become(InvoiceItemSqlDao.class);
      if (isInvoiceAdjusted && !isInvoiceItemAdjusted) {
        final BigDecimal maxBalanceToAdjust=(invoiceBalanceAfterRefund.compareTo(BigDecimal.ZERO) <= 0) ? BigDecimal.ZERO : invoiceBalanceAfterRefund;
        final BigDecimal requestedPositiveAmountToAdjust=requestedPositiveAmount.compareTo(maxBalanceToAdjust) > 0 ? maxBalanceToAdjust : requestedPositiveAmount;
        if (requestedPositiveAmountToAdjust.compareTo(BigDecimal.ZERO) > 0) {
          final InvoiceItem adjItem=new RefundAdjInvoiceItem(invoice.getId(),invoice.getAccountId(),context.getCreatedDate().toLocalDate(),requestedPositiveAmountToAdjust.negate(),invoice.getCurrency());
          transInvoiceItemDao.create(adjItem,context);
          final Long adjItemRecordId=transInvoiceItemDao.getRecordId(adjItem.getId().toString(),context);
          audits.add(new EntityAudit(TableName.INVOICE_ITEMS,adjItemRecordId,ChangeType.INSERT));
        }
      }
 else       if (isInvoiceAdjusted) {
        for (        final UUID invoiceItemId : invoiceItemIdsWithAmounts.keySet()) {
          final BigDecimal adjAmount=invoiceItemIdsWithAmounts.get(invoiceItemId);
          final InvoiceItem item=createAdjustmentItem(transInvoiceDao,invoice.getId(),invoiceItemId,adjAmount,invoice.getCurrency(),context.getCreatedDate().toLocalDate(),context);
          transInvoiceItemDao.create(item,context);
          final Long itemRecordId=transInvoiceItemDao.getRecordId(item.getId().toString(),context);
          audits.add(new EntityAudit(TableName.INVOICE_ITEMS,itemRecordId,ChangeType.INSERT));
        }
      }
      notifyBusOfInvoiceAdjustment(transactional,invoice.getId(),invoice.getAccountId(),context.getUserToken());
      transactional.insertAuditFromTransaction(audits,context);
      return refund;
    }
  }
);
}
