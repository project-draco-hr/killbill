{
  return transactionalSqlDao.execute(new EntitySqlDaoTransactionWrapper<InvoicePayment>(){
    @Override public InvoicePayment inTransaction(    final EntitySqlDaoWrapperFactory<EntitySqlDao> entitySqlDaoWrapperFactory) throws Exception {
      final InvoicePaymentSqlDao transactional=entitySqlDaoWrapperFactory.become(InvoicePaymentSqlDao.class);
      final BigDecimal maxChargedBackAmount=getRemainingAmountPaidFromTransaction(invoicePaymentId,transactional,context);
      final BigDecimal requestedChargedBackAmout=(amount == null) ? maxChargedBackAmount : amount;
      if (requestedChargedBackAmout.compareTo(BigDecimal.ZERO) <= 0) {
        throw new InvoiceApiException(ErrorCode.CHARGE_BACK_AMOUNT_IS_NEGATIVE);
      }
      if (requestedChargedBackAmout.compareTo(maxChargedBackAmount) > 0) {
        throw new InvoiceApiException(ErrorCode.CHARGE_BACK_AMOUNT_TOO_HIGH,requestedChargedBackAmout,maxChargedBackAmount);
      }
      final InvoicePayment payment=entitySqlDaoWrapperFactory.become(InvoicePaymentSqlDao.class).getById(invoicePaymentId.toString(),context);
      if (payment == null) {
        throw new InvoiceApiException(ErrorCode.INVOICE_PAYMENT_NOT_FOUND,invoicePaymentId.toString());
      }
 else {
        final InvoicePayment chargeBack=new DefaultInvoicePayment(UUID.randomUUID(),InvoicePaymentType.CHARGED_BACK,payment.getPaymentId(),payment.getInvoiceId(),context.getCreatedDate(),requestedChargedBackAmout.negate(),payment.getCurrency(),null,payment.getId());
        transactional.create(chargeBack,context);
        final UUID accountId=transactional.getAccountIdFromInvoicePaymentId(chargeBack.getId().toString(),context);
        notifyBusOfInvoiceAdjustment(transactional,payment.getInvoiceId(),accountId,context.getUserToken(),context);
        return chargeBack;
      }
    }
  }
);
}
