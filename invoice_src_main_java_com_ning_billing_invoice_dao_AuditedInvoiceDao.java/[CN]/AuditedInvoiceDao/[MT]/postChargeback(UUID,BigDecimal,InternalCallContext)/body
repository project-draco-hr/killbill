{
  return invoicePaymentSqlDao.inTransaction(new Transaction<InvoicePayment,InvoicePaymentSqlDao>(){
    @Override public InvoicePayment inTransaction(    final InvoicePaymentSqlDao transactional,    final TransactionStatus status) throws Exception {
      final BigDecimal maxChargedBackAmount=getRemainingAmountPaidFromTransaction(invoicePaymentId,transactional,context);
      final BigDecimal requestedChargedBackAmout=(amount == null) ? maxChargedBackAmount : amount;
      if (requestedChargedBackAmout.compareTo(BigDecimal.ZERO) <= 0) {
        throw new InvoiceApiException(ErrorCode.CHARGE_BACK_AMOUNT_IS_NEGATIVE);
      }
      if (requestedChargedBackAmout.compareTo(maxChargedBackAmount) > 0) {
        throw new InvoiceApiException(ErrorCode.CHARGE_BACK_AMOUNT_TOO_HIGH,requestedChargedBackAmout,maxChargedBackAmount);
      }
      final InvoicePayment payment=invoicePaymentSqlDao.getById(invoicePaymentId.toString(),context);
      if (payment == null) {
        throw new InvoiceApiException(ErrorCode.INVOICE_PAYMENT_NOT_FOUND,invoicePaymentId.toString());
      }
 else {
        final InvoicePayment chargeBack=new DefaultInvoicePayment(UUID.randomUUID(),InvoicePaymentType.CHARGED_BACK,payment.getPaymentId(),payment.getInvoiceId(),context.getCreatedDate(),requestedChargedBackAmout.negate(),payment.getCurrency(),null,payment.getId());
        transactional.create(chargeBack,context);
        final Long recordId=transactional.getRecordId(chargeBack.getId().toString(),context);
        final EntityAudit audit=new EntityAudit(TableName.INVOICE_PAYMENTS,recordId,ChangeType.INSERT);
        transactional.insertAuditFromTransaction(audit,context);
        final UUID accountId=transactional.getAccountIdFromInvoicePaymentId(chargeBack.getId().toString(),context);
        notifyBusOfInvoiceAdjustment(transactional,payment.getInvoiceId(),accountId,context.getUserToken());
        return chargeBack;
      }
    }
  }
);
}
