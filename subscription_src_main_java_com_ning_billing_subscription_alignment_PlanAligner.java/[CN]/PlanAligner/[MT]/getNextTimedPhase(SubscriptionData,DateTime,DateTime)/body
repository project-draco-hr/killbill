{
  try {
    final SubscriptionBaseTransitionData lastPlanTransition=subscription.getInitialTransitionForCurrentPlan();
    if (effectiveDate.isBefore(lastPlanTransition.getEffectiveTransitionTime())) {
      throw new SubscriptionError(String.format("Cannot specify an effectiveDate prior to last Plan Change, subscription = %s, effectiveDate = %s",subscription.getId(),effectiveDate));
    }
switch (lastPlanTransition.getTransitionType()) {
case MIGRATE_ENTITLEMENT:
case CREATE:
case RE_CREATE:
case TRANSFER:
      final List<TimedPhase> timedPhases=getTimedPhaseOnCreate(subscription.getAlignStartDate(),subscription.getBundleStartDate(),lastPlanTransition.getNextPlan(),lastPlanTransition.getNextPhase().getPhaseType(),lastPlanTransition.getNextPriceList().getName(),requestedDate);
    return getTimedPhase(timedPhases,effectiveDate,WhichPhase.NEXT);
case CHANGE:
  return getTimedPhaseOnChange(subscription.getAlignStartDate(),subscription.getBundleStartDate(),lastPlanTransition.getPreviousPhase(),lastPlanTransition.getPreviousPlan(),lastPlanTransition.getPreviousPriceList().getName(),lastPlanTransition.getNextPlan(),lastPlanTransition.getNextPriceList().getName(),requestedDate,effectiveDate,WhichPhase.NEXT);
default :
throw new SubscriptionError(String.format("Unexpected initial transition %s for current plan %s on subscription %s",lastPlanTransition.getTransitionType(),subscription.getCurrentPlan(),subscription.getId()));
}
}
 catch (Exception e) {
throw new SubscriptionError(String.format("Could not compute next phase change for subscription %s",subscription.getId()),e);
}
}
