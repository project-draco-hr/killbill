{
  final Map<UUID,TargetState> targetStates=new HashMap<UUID,TargetState>();
  for (  UUID cur : allEntitlementUUIDs) {
    targetStates.put(cur,new TargetState());
  }
  int index=-1;
  final Iterator<SubscriptionEvent> it=result.iterator();
  DefaultSubscriptionEvent cur=null;
  while (it.hasNext()) {
    cur=(DefaultSubscriptionEvent)it.next();
    index++;
    final int compEffectiveDate=bsEffectiveDate.compareTo(cur.getEffectiveDate());
    final boolean shouldContinue=(compEffectiveDate > 0 || (compEffectiveDate == 0 && bs.getCreatedDate().compareTo(cur.getCreatedDate()) >= 0));
    final TargetState curTargetState=targetStates.get(cur.getEntitlementId());
    if (shouldContinue) {
switch (cur.getSubscriptionEventType()) {
case START_ENTITLEMENT:
        curTargetState.setEntitlementStarted();
      break;
case STOP_ENTITLEMENT:
    curTargetState.setEntitlementStopped();
  break;
case START_BILLING:
curTargetState.setBillingStarted();
break;
case PAUSE_BILLING:
case PAUSE_ENTITLEMENT:
curTargetState.addEntitlementEvent(cur);
break;
case STOP_BILLING:
curTargetState.setBillingStopped();
break;
}
}
 else {
break;
}
}
final List<UUID> targetEntitlementIds=bs.getType() == BlockingStateType.SUBSCRIPTION ? ImmutableList.<UUID>of(bs.getBlockedId()) : ImmutableList.<UUID>copyOf(allEntitlementUUIDs);
for (UUID target : targetEntitlementIds) {
final SubscriptionEvent[] prevNext=findPrevNext(result,target,cur,bs);
final TargetState curTargetState=targetStates.get(target);
final List<SubscriptionEventType> eventTypes=curTargetState.addStateAndReturnEventTypes(bs);
for (SubscriptionEventType t : eventTypes) {
newEvents.add(toSubscriptionEvent(prevNext[0],prevNext[1],target,bs,t,accountTimeZone));
}
}
return index;
}
