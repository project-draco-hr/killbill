{
  int index=-1;
  final Iterator<SubscriptionEvent> it=result.iterator();
  while (it.hasNext()) {
    final DefaultSubscriptionEvent cur=(DefaultSubscriptionEvent)it.next();
    index++;
switch (cur.getSubscriptionEventType()) {
case START_ENTITLEMENT:
      blockedEntitlementMap.put(cur.getEntitlementId(),Boolean.FALSE);
    break;
case START_BILLING:
  blockedBillingMap.put(cur.getEntitlementId(),Boolean.FALSE);
break;
case PAUSE_ENTITLEMENT:
case STOP_ENTITLEMENT:
blockedEntitlementMap.put(cur.getEntitlementId(),Boolean.TRUE);
break;
case PAUSE_BILLING:
case STOP_BILLING:
blockedBillingMap.put(cur.getEntitlementId(),Boolean.TRUE);
break;
}
final int compEffectiveDate=bsEffectiveDate.compareTo(cur.getEffectiveDate());
if (compEffectiveDate < 0 || (compEffectiveDate == 0 && bs.getCreatedDate().compareTo(cur.getCreatedDate()) <= 0)) {
continue;
}
final DefaultSubscriptionEvent next=it.hasNext() ? (DefaultSubscriptionEvent)it.next() : null;
final List<UUID> targetEntitlementIds=bs.getType() == BlockingStateType.SUBSCRIPTION ? ImmutableList.<UUID>of(bs.getId()) : ImmutableList.<UUID>copyOf(allEntitlementUUIDs);
for (UUID target : targetEntitlementIds) {
final Boolean isResumeEntitlement=(blockedEntitlementMap.get(bs.getId()) && !bs.isBlockEntitlement());
final Boolean isPauseEntitlement=(!blockedEntitlementMap.get(bs.getId()) && bs.isBlockEntitlement());
final Boolean isResumeBilling=(blockedBillingMap.get(bs.getId()) && !bs.isBlockBilling());
final Boolean isPauseBilling=(!blockedBillingMap.get(bs.getId()) && bs.isBlockBilling());
final Boolean isServiceStateChange=!(isResumeEntitlement || isPauseEntitlement || isResumeBilling|| isPauseBilling);
if (isResumeEntitlement) {
newEvents.add(toSubscriptionEvent(cur,next,target,bs,SubscriptionEventType.RESUME_ENTITLEMENT,accountTimeZone));
}
 else if (isPauseEntitlement) {
newEvents.add(toSubscriptionEvent(cur,next,target,bs,SubscriptionEventType.PAUSE_ENTITLEMENT,accountTimeZone));
}
if (isResumeBilling) {
newEvents.add(toSubscriptionEvent(cur,next,target,bs,SubscriptionEventType.RESUME_BILLING,accountTimeZone));
}
 else if (isPauseBilling) {
newEvents.add(toSubscriptionEvent(cur,next,target,bs,SubscriptionEventType.PAUSE_BILLING,accountTimeZone));
}
if (isServiceStateChange) {
newEvents.add(toSubscriptionEvent(cur,next,target,bs,SubscriptionEventType.SERVICE_STATE_CHANGE,accountTimeZone));
}
}
break;
}
return index;
}
