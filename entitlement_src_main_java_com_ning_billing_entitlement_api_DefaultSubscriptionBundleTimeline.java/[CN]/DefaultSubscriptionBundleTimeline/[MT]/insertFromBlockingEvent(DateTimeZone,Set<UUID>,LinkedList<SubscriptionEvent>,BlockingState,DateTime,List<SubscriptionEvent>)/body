{
  final Map<UUID,TargetState> targetStates=new HashMap<UUID,TargetState>();
  for (  UUID cur : allEntitlementUUIDs) {
    targetStates.put(cur,new TargetState());
  }
  int index=-1;
  final Iterator<SubscriptionEvent> it=result.iterator();
  DefaultSubscriptionEvent curInsertion=null;
  while (it.hasNext()) {
    DefaultSubscriptionEvent cur=(DefaultSubscriptionEvent)it.next();
    index++;
    final int compEffectiveDate=bsEffectiveDate.compareTo(cur.getEffectiveDateTime());
    final boolean shouldContinue=(compEffectiveDate > 0 || (compEffectiveDate == 0 && bs.getCreatedDate().compareTo(cur.getCreatedDate()) >= 0));
    if (!shouldContinue) {
      break;
    }
    final TargetState curTargetState=targetStates.get(cur.getEntitlementId());
switch (cur.getSubscriptionEventType()) {
case START_ENTITLEMENT:
      curTargetState.setEntitlementStarted();
    break;
case STOP_ENTITLEMENT:
  curTargetState.setEntitlementStopped();
break;
case START_BILLING:
curTargetState.setBillingStarted();
break;
case PAUSE_BILLING:
case PAUSE_ENTITLEMENT:
curTargetState.addEntitlementEvent(cur);
break;
case STOP_BILLING:
curTargetState.setBillingStopped();
break;
}
curInsertion=cur;
}
final List<UUID> targetEntitlementIds=bs.getType() == BlockingStateType.SUBSCRIPTION ? ImmutableList.<UUID>of(bs.getBlockedId()) : ImmutableList.<UUID>copyOf(allEntitlementUUIDs);
for (UUID target : targetEntitlementIds) {
final SubscriptionEvent[] prevNext=findPrevNext(result,target,curInsertion);
final TargetState curTargetState=targetStates.get(target);
final List<SubscriptionEventType> eventTypes=curTargetState.addStateAndReturnEventTypes(bs);
for (SubscriptionEventType t : eventTypes) {
newEvents.add(toSubscriptionEvent(prevNext[0],prevNext[1],target,bs,t,accountTimeZone));
}
}
return index;
}
