{
  final int chunkId=rs.getInt("chunk_id");
  final int sourceId=rs.getInt("source_id");
  final int metricId=rs.getInt("sample_kind_id");
  final int sampleCount=rs.getInt("sample_count");
  final DateTime startTime=DateTimeUtils.dateTimeFromUnixSeconds(rs.getInt("start_time"));
  final DateTime endTime=DateTimeUtils.dateTimeFromUnixSeconds(rs.getInt("end_time"));
  final int aggregationLevel=rs.getInt("aggregation_level");
  final boolean notValid=rs.getInt("not_valid") == 0 ? false : true;
  final boolean dontAggregate=rs.getInt("dont_aggregate") == 0 ? false : true;
  byte[] samplesAndTimes=rs.getBytes("in_row_samples");
  if (rs.wasNull()) {
    final Blob blobSamples=rs.getBlob("blob_samples");
    if (rs.wasNull()) {
      samplesAndTimes=new byte[4];
    }
 else {
      samplesAndTimes=blobSamples.getBytes(1,(int)blobSamples.length());
    }
  }
  final TimeBytesAndSampleBytes bytesPair=TimesAndSamplesCoder.getTimesBytesAndSampleBytes(samplesAndTimes);
  return new TimelineChunk(chunkId,sourceId,metricId,startTime,endTime,bytesPair,sampleCount,aggregationLevel,notValid,dontAggregate);
}
