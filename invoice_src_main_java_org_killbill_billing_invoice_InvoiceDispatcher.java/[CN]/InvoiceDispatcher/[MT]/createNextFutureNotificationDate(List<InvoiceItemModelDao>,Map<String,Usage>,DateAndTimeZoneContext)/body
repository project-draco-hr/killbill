{
  final Map<UUID,List<DateTime>> result=new HashMap<UUID,List<DateTime>>();
  final Map<String,LocalDate> perSubscriptionUsage=new HashMap<String,LocalDate>();
  for (  final InvoiceItemModelDao item : invoiceItems) {
    List<DateTime> perSubscriptionCallback=result.get(item.getSubscriptionId());
    if (perSubscriptionCallback == null && (item.getType() == InvoiceItemType.RECURRING || item.getType() == InvoiceItemType.USAGE)) {
      perSubscriptionCallback=new ArrayList<DateTime>();
      result.put(item.getSubscriptionId(),perSubscriptionCallback);
    }
switch (item.getType()) {
case RECURRING:
      if ((item.getEndDate() != null) && (item.getAmount() == null || item.getAmount().compareTo(BigDecimal.ZERO) >= 0)) {
        perSubscriptionCallback.add(dateAndTimeZoneContext.computeUTCDateTimeFromLocalDate(item.getEndDate()));
      }
    break;
case USAGE:
  final Usage usage=knownUsages.get(item.getUsageName());
final String key=item.getSubscriptionId().toString() + ":" + usage.getName();
final LocalDate perSubscriptionUsageRecurringDate=perSubscriptionUsage.get(key);
if (perSubscriptionUsageRecurringDate == null || perSubscriptionUsageRecurringDate.compareTo(item.getEndDate()) < 0) {
perSubscriptionUsage.put(key,item.getEndDate());
}
break;
default :
}
}
for (final String key : perSubscriptionUsage.keySet()) {
final String[] parts=key.split(":");
final UUID subscriptionId=UUID.fromString(parts[0]);
final List<DateTime> perSubscriptionCallback=result.get(subscriptionId);
final String usageName=parts[1];
final Usage usage=knownUsages.get(usageName);
final LocalDate endDate=perSubscriptionUsage.get(key);
final LocalDate nextCallbackUsageDate=(usage.getBillingMode() == BillingMode.IN_ARREAR) ? endDate.plusMonths(usage.getBillingPeriod().getNumberOfMonths()) : endDate;
perSubscriptionCallback.add(dateAndTimeZoneContext.computeUTCDateTimeFromLocalDate(nextCallbackUsageDate));
}
return result;
}
