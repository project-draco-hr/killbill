{
  final boolean isDryRun=dryRunArguments != null;
  Preconditions.checkArgument(inputTargetDateTime != null || (dryRunArguments != null && DryRunType.UPCOMING_INVOICE.equals(dryRunArguments.getDryRunType())),"inputTargetDateTime is required in non dryRun mode");
  try {
    final BillingEventSet billingEvents=billingApi.getBillingEventsForAccountAndUpdateAccountBCD(accountId,dryRunArguments,context);
    if (billingEvents.isEmpty()) {
      return null;
    }
    final List<DateTime> candidateDateTimes=(inputTargetDateTime != null) ? ImmutableList.of(inputTargetDateTime) : getUpcomingInvoiceCandidateDates(getFilteredSubscriptionIds(dryRunArguments,billingEvents),context);
    for (    final DateTime curTargetDateTime : candidateDateTimes) {
      final Invoice invoice=processAccountWithLockAndInputTargetDate(accountId,curTargetDateTime,billingEvents,isDryRun,context);
      if (invoice != null) {
        return invoice;
      }
    }
    return null;
  }
 catch (  CatalogApiException e) {
    log.error("Failed handling SubscriptionBase change.",e);
    return null;
  }
}
