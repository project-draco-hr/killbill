{
  final Map<UUID,List<SubscriptionNotification>> result=new HashMap<UUID,List<SubscriptionNotification>>();
  final Map<String,LocalDate> perSubscriptionUsage=new HashMap<String,LocalDate>();
  for (  final InvoiceItemModelDao item : invoiceItems) {
    List<SubscriptionNotification> perSubscriptionCallback=result.get(item.getSubscriptionId());
    if (perSubscriptionCallback == null && (item.getType() == InvoiceItemType.RECURRING || item.getType() == InvoiceItemType.USAGE)) {
      perSubscriptionCallback=new ArrayList<SubscriptionNotification>();
      result.put(item.getSubscriptionId(),perSubscriptionCallback);
    }
switch (item.getType()) {
case RECURRING:
      if ((item.getEndDate() != null) && (item.getAmount() == null || item.getAmount().compareTo(BigDecimal.ZERO) >= 0)) {
        perSubscriptionCallback.add(new SubscriptionNotification(dateAndTimeZoneContext.computeUTCDateTimeFromLocalDate(item.getEndDate()),true));
      }
    break;
case USAGE:
  final String key=item.getSubscriptionId().toString() + ":" + item.getUsageName();
final LocalDate perSubscriptionUsageRecurringDate=perSubscriptionUsage.get(key);
if (perSubscriptionUsageRecurringDate == null || perSubscriptionUsageRecurringDate.compareTo(item.getEndDate()) < 0) {
perSubscriptionUsage.put(key,item.getEndDate());
}
break;
default :
}
}
for (final String key : perSubscriptionUsage.keySet()) {
final String[] parts=key.split(":");
final UUID subscriptionId=UUID.fromString(parts[0]);
final List<SubscriptionNotification> perSubscriptionCallback=result.get(subscriptionId);
final String usageName=parts[1];
final LocalDate endDate=perSubscriptionUsage.get(key);
final DateTime subscriptionUsageCallbackDate=getNextUsageBillingDate(subscriptionId,usageName,endDate,dateAndTimeZoneContext,billingEvents);
perSubscriptionCallback.add(new SubscriptionNotification(subscriptionUsageCallbackDate,true));
}
final boolean isInvoiceNotificationEnabled=invoiceConfig.getDryRunNotificationSchedule().getMillis() > 0;
if (isInvoiceNotificationEnabled) {
final Map<UUID,DateTime> upcomingPhasesForSubscriptions=subscriptionApi.getNextFutureEventForSubscriptions(SubscriptionBaseTransitionType.PHASE,context);
for (UUID cur : upcomingPhasesForSubscriptions.keySet()) {
final DateTime curDate=upcomingPhasesForSubscriptions.get(cur);
List<SubscriptionNotification> resultValue=result.get(cur);
if (resultValue == null) {
resultValue=new ArrayList<SubscriptionNotification>();
}
resultValue.add(new SubscriptionNotification(curDate,false));
result.put(cur,resultValue);
}
}
return new FutureAccountNotifications(dateAndTimeZoneContext,result);
}
