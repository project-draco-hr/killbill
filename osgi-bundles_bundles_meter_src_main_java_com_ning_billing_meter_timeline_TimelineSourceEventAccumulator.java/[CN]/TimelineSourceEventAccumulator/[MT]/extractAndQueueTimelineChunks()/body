{
  if (times.size() > 0) {
    final Map<Integer,TimelineChunk> chunkMap=new HashMap<Integer,TimelineChunk>();
    final byte[] timeBytes=timelineCoder.compressDateTimes(times);
    for (    final Map.Entry<Integer,TimelineChunkAccumulator> entry : timelines.entrySet()) {
      final int metricId=entry.getKey();
      final TimelineChunkAccumulator accumulator=entry.getValue();
      final TimelineChunk chunk=accumulator.extractTimelineChunkAndReset(startTime,endTime,timeBytes);
      chunkMap.put(metricId,chunk);
    }
    times.clear();
    sampleCount=0;
    final long counter=pendingChunkMapIdCounter++;
    final PendingChunkMap newChunkMap=new PendingChunkMap(this,counter,chunkMap);
    pendingChunkMaps.add(newChunkMap);
    backgroundWriter.addPendingChunkMap(newChunkMap);
  }
}
