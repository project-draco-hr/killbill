{
  final Collection<BlockingStateModelDao> blockingStatesOnDiskCopy=new LinkedList<BlockingStateModelDao>(blockingStatesOnDisk);
  final Iterable<SubscriptionBase> baseSubscriptionsToConsider;
  try {
    if (blockableId == null) {
      final Iterable<SubscriptionBase> subscriptions=Iterables.<SubscriptionBase>concat(subscriptionInternalApi.getSubscriptionsForAccount(context).values());
      baseSubscriptionsToConsider=Iterables.<SubscriptionBase>filter(subscriptions,new Predicate<SubscriptionBase>(){
        @Override public boolean apply(        final SubscriptionBase input){
          return ProductCategory.BASE.equals(input.getCategory()) && !EntitlementState.CANCELLED.equals(input.getState());
        }
      }
);
    }
 else {
      final SubscriptionBase addOnSubscription;
      try {
        addOnSubscription=subscriptionInternalApi.getSubscriptionFromId(blockableId,context);
      }
 catch (      SubscriptionBaseApiException ignored) {
        return blockingStatesOnDisk;
      }
      if (ProductCategory.ADD_ON.equals(addOnSubscription.getCategory())) {
        final SubscriptionBase baseSubscription=subscriptionInternalApi.getBaseSubscription(addOnSubscription.getBundleId(),context);
        baseSubscriptionsToConsider=ImmutableList.<SubscriptionBase>of(baseSubscription);
      }
 else {
        return blockingStatesOnDisk;
      }
    }
  }
 catch (  SubscriptionBaseApiException e) {
    log.error("Error retrieving subscriptions for account record id " + context.getAccountRecordId(),e);
    throw new RuntimeException(e);
  }
  final DateTime now=clock.getUTCNow();
  for (  final SubscriptionBase subscriptionBase : baseSubscriptionsToConsider) {
    final Collection<BlockingState> blockingStates;
    try {
      blockingStates=entitlementUtils.computeFutureBlockingStatesForAssociatedAddons(sqlDao.getBlockingHistoryForService(subscriptionBase.getId(),EntitlementService.ENTITLEMENT_SERVICE_NAME,context),subscriptionBase,now,context);
    }
 catch (    EntitlementApiException e) {
      log.error("Error computing blocking states for addons for account record id " + context.getAccountRecordId(),e);
      throw new RuntimeException(e);
    }
    for (    final BlockingState blockingState : blockingStates) {
      final BlockingStateModelDao blockingStateModelDao=new BlockingStateModelDao(blockingState,now,now);
      blockingStatesOnDiskCopy.add(blockingStateModelDao);
    }
  }
  return BLOCKING_STATE_MODEL_DAO_ORDERING.immutableSortedCopy(blockingStatesOnDiskCopy);
}
