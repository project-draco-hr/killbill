{
  final DateTime now=clock.getUTCNow();
  final DateTime then=now.minusDays(1);
  final Plan nextPlan=catalogService.getFullCatalog().findPlan("PickupTrialEvergreen10USD",now);
  final PlanPhase nextPhase=nextPlan.getAllPhases()[1];
  final PriceList nextPriceList=catalogService.getFullCatalog().findPriceList(PriceListSet.DEFAULT_PRICELIST_NAME,now);
  final EffectiveSubscriptionEvent t=new MockEffectiveSubscriptionEvent(eventId,subId,bunId,then,now,null,null,null,null,SubscriptionState.ACTIVE,nextPlan.getName(),nextPhase.getName(),nextPriceList.getName(),1L,null,SubscriptionTransitionType.CREATE,0,null);
  effectiveSubscriptionTransitions.add(t);
  final AccountUserApi accountApi=Mockito.mock(AccountUserApi.class);
  final Account account=Mockito.mock(Account.class);
  Mockito.when(account.getBillCycleDay()).thenReturn(new MockBillCycleDay(32));
  Mockito.when(account.getCurrency()).thenReturn(Currency.USD);
  Mockito.when(account.getTimeZone()).thenReturn(DateTimeZone.UTC);
  Mockito.when(accountApi.getAccountById(Mockito.<UUID>any())).thenReturn(account);
  Mockito.when(account.getId()).thenReturn(UUID.randomUUID());
  ((MockCatalog)catalogService.getFullCatalog()).setBillingAlignment(BillingAlignment.ACCOUNT);
  final SortedSet<BlockingState> blockingStates=new TreeSet<BlockingState>();
  blockingStates.add(new DefaultBlockingState(bunId,DISABLED_BUNDLE,Blockable.Type.SUBSCRIPTION_BUNDLE,"test",true,true,true,now.plusDays(1)));
  blockingStates.add(new DefaultBlockingState(bunId,CLEAR_BUNDLE,Blockable.Type.SUBSCRIPTION_BUNDLE,"test",false,false,false,now.plusDays(2)));
  final BlockingCalculator blockingCal=new BlockingCalculator(new BlockingApi(){
    @Override public <T extends Blockable>void setBlockingState(    final BlockingState state){
    }
    @Override public BlockingState getBlockingStateFor(    final UUID overdueableId){
      return null;
    }
    @Override public BlockingState getBlockingStateFor(    final Blockable overdueable){
      return null;
    }
    @Override public SortedSet<BlockingState> getBlockingHistory(    final UUID overdueableId){
      if (overdueableId == bunId) {
        return blockingStates;
      }
      return new TreeSet<BlockingState>();
    }
    @Override public SortedSet<BlockingState> getBlockingHistory(    final Blockable overdueable){
      return new TreeSet<BlockingState>();
    }
  }
);
  final BillCycleDayCalculator bcdCalculator=new BillCycleDayCalculator(catalogService,entitlementApi);
  final CallContextFactory factory=new DefaultCallContextFactory(clock);
  final BillingApi api=new DefaultBillingApi(null,factory,accountApi,bcdCalculator,entitlementApi,blockingCal,catalogService,tagApi);
  final SortedSet<BillingEvent> events=api.getBillingEventsForAccountAndUpdateAccountBCD(new UUID(0L,0L));
  Assert.assertEquals(events.size(),3);
  final Iterator<BillingEvent> it=events.iterator();
  checkEvent(it.next(),nextPlan,32,subId,now,nextPhase,SubscriptionTransitionType.CREATE.toString(),nextPhase.getFixedPrice(),nextPhase.getRecurringPrice());
  checkEvent(it.next(),nextPlan,32,subId,now.plusDays(1),nextPhase,SubscriptionTransitionType.CANCEL.toString(),new MockPrice("0"),new MockPrice("0"));
  checkEvent(it.next(),nextPlan,32,subId,now.plusDays(2),nextPhase,SubscriptionTransitionType.RE_CREATE.toString(),nextPhase.getFixedPrice(),nextPhase.getRecurringPrice());
}
