{
  try {
    final NotificationQueueHandler queueHandler=new NotificationQueueHandler(){
      @Override public void handleReadyNotification(      final NotificationKey inputKey,      final DateTime eventDateTime,      final UUID fromNotificationQueueUserToken,      final Long accountRecordId,      final Long tenantRecordId){
        if (!(inputKey instanceof EntitlementNotificationKey)) {
          log.error("Entitlement service received an unexpected event type {}" + inputKey.getClass().getName());
          return;
        }
        final EntitlementNotificationKey key=(EntitlementNotificationKey)inputKey;
        final EntitlementEvent event=dao.getEventById(key.getEventId(),internalCallContextFactory.createInternalTenantContext(tenantRecordId,accountRecordId));
        if (event == null) {
          log.warn("Failed to extract event for notification key {}",inputKey);
          return;
        }
        final UUID userToken=(event.getType() == EventType.API_USER) ? ((ApiEvent)event).getUserToken() : fromNotificationQueueUserToken;
        final InternalCallContext context=internalCallContextFactory.createInternalCallContext(tenantRecordId,accountRecordId,"SubscriptionEventQueue",CallOrigin.INTERNAL,UserType.SYSTEM,userToken);
        processEventReady(event,key.getSeqId(),context);
      }
    }
;
    final NotificationConfig notificationConfig=new NotificationConfig(){
      @Override public long getSleepTimeMs(){
        return config.getSleepTimeMs();
      }
      @Override public boolean isNotificationProcessingOff(){
        return config.isNotificationProcessingOff();
      }
    }
;
    subscriptionEventQueue=notificationQueueService.createNotificationQueue(ENTITLEMENT_SERVICE_NAME,NOTIFICATION_QUEUE_NAME,queueHandler,notificationConfig);
  }
 catch (  NotificationQueueAlreadyExists e) {
    throw new RuntimeException(e);
  }
}
