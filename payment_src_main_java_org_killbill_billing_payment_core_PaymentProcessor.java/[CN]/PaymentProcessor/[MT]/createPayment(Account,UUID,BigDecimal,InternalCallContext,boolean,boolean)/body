{
  final PaymentPluginApi externalPaymentPlugin;
  if (isExternalPayment) {
    externalPaymentPlugin=paymentMethodProcessor.getExternalPaymentProviderPlugin(account,context);
  }
 else {
    externalPaymentPlugin=null;
  }
  try {
    return paymentPluginDispatcher.dispatchWithAccountLock(new CallableWithAccountLock<Payment>(locker,account.getExternalKey(),new WithAccountLockCallback<Payment>(){
      @Override public Payment doOperation() throws PaymentApiException {
        try {
          final Invoice invoice=rebalanceAndGetInvoice(account.getId(),invoiceId,context);
          if (invoice == null || invoice.isMigrationInvoice()) {
            log.error("Received invoice for payment that is a migration invoice - don't know how to handle those yet: {}",invoice);
            return null;
          }
          final BigDecimal requestedAmount=getAndValidatePaymentAmount(invoice,inputAmount,isInstantPayment);
          final PaymentPluginApi plugin;
          final UUID paymentMethodId;
          try {
            if (isExternalPayment) {
              plugin=externalPaymentPlugin;
              paymentMethodId=paymentMethodProcessor.getExternalPaymentMethod(account,context).getId();
            }
 else {
              plugin=getPaymentProviderPlugin(account,context);
              paymentMethodId=account.getPaymentMethodId();
            }
          }
 catch (          final PaymentApiException e) {
            processNewPaymentForMissingDefaultPaymentMethodWithAccountLocked(account,invoice,requestedAmount,context);
            final PaymentErrorInternalEvent event=new DefaultPaymentErrorEvent(account.getId(),invoiceId,null,ErrorCode.PAYMENT_NO_DEFAULT_PAYMENT_METHOD.toString(),context.getAccountRecordId(),context.getTenantRecordId(),context.getUserToken());
            postPaymentEvent(event,account.getId(),context);
            throw e;
          }
          final boolean isAccountAutoPayOff=isAccountAutoPayOff(account.getId(),context);
          setUnsaneAccount_AUTO_PAY_OFFWithAccountLock(account.getId(),paymentMethodId,isAccountAutoPayOff,context,isInstantPayment);
          if (!isInstantPayment && isAccountAutoPayOff) {
            return processNewPaymentForAutoPayOffWithAccountLocked(paymentMethodId,account,invoice,requestedAmount,context);
          }
 else {
            return processNewPaymentWithAccountLocked(paymentMethodId,plugin,account,invoice,requestedAmount,isInstantPayment,context);
          }
        }
 catch (        final InvoiceApiException e) {
          throw new PaymentApiException(e);
        }
      }
    }
));
  }
 catch (  final TimeoutException e) {
    if (isInstantPayment) {
      throw new PaymentApiException(ErrorCode.PAYMENT_PLUGIN_TIMEOUT,account.getId(),invoiceId);
    }
 else {
      log.warn(String.format("Payment from Account %s, Invoice %s timedout",account.getId(),invoiceId));
      return null;
    }
  }
catch (  final RuntimeException e) {
    log.error("Failure when dispatching payment for invoice " + invoiceId,e);
    if (isInstantPayment) {
      throw new PaymentApiException(ErrorCode.PAYMENT_INTERNAL_ERROR,invoiceId);
    }
 else {
      return null;
    }
  }
}
