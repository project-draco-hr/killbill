{
  final Collection<BlockingState> blockingStatesOnDiskCopy=new LinkedList<BlockingState>(blockingStatesOnDisk);
  final Iterable<SubscriptionBase> baseSubscriptionsToConsider;
  final Iterable<EventsStream> eventsStreams;
  try {
    if (blockingStateType == null) {
      final Map<UUID,List<SubscriptionBase>> subscriptions=subscriptionInternalApi.getSubscriptionsForAccount(context);
      baseSubscriptionsToConsider=Iterables.<SubscriptionBase>filter(Iterables.<SubscriptionBase>concat(subscriptions.values()),new Predicate<SubscriptionBase>(){
        @Override public boolean apply(        final SubscriptionBase input){
          return ProductCategory.BASE.equals(input.getCategory()) && !EntitlementState.CANCELLED.equals(input.getState());
        }
      }
);
      eventsStreams=Iterables.<EventsStream>concat(eventsStreamBuilder.buildForAccount(subscriptions,context).getEventsStreams().values());
    }
 else     if (BlockingStateType.SUBSCRIPTION.equals(blockingStateType)) {
      final SubscriptionBase subscription=subscriptionInternalApi.getSubscriptionFromId(blockableId,context);
      if (ProductCategory.ADD_ON.equals(subscription.getCategory())) {
        final SubscriptionBase baseSubscription=subscriptionInternalApi.getBaseSubscription(subscription.getBundleId(),context);
        baseSubscriptionsToConsider=ImmutableList.<SubscriptionBase>of(baseSubscription);
        eventsStreams=ImmutableList.<EventsStream>of(eventsStreamBuilder.buildForEntitlement(baseSubscription,context));
      }
 else {
        return blockingStatesOnDisk;
      }
    }
 else {
      return blockingStatesOnDisk;
    }
  }
 catch (  SubscriptionBaseApiException e) {
    log.error("Error retrieving subscriptions for account record id " + context.getAccountRecordId(),e);
    throw new RuntimeException(e);
  }
catch (  EntitlementApiException e) {
    log.error("Error computing blocking states for addons for account record id " + context.getAccountRecordId(),e);
    throw new RuntimeException(e);
  }
  return addBlockingStatesNotOnDisk(blockableId,blockingStateType,blockingStatesOnDiskCopy,baseSubscriptionsToConsider,eventsStreams);
}
