{
  final Collection<BlockingState> blockingStatesOnDiskCopy=new LinkedList<BlockingState>(blockingStatesOnDisk);
  final Iterable<SubscriptionBase> baseSubscriptionsToConsider;
  try {
    if (blockingStateType == null) {
      final Iterable<SubscriptionBase> subscriptions=Iterables.<SubscriptionBase>concat(subscriptionInternalApi.getSubscriptionsForAccount(context).values());
      baseSubscriptionsToConsider=Iterables.<SubscriptionBase>filter(subscriptions,new Predicate<SubscriptionBase>(){
        @Override public boolean apply(        final SubscriptionBase input){
          return ProductCategory.BASE.equals(input.getCategory()) && !EntitlementState.CANCELLED.equals(input.getState());
        }
      }
);
    }
 else     if (BlockingStateType.SUBSCRIPTION.equals(blockingStateType)) {
      final SubscriptionBase subscription=subscriptionInternalApi.getSubscriptionFromId(blockableId,context);
      if (ProductCategory.ADD_ON.equals(subscription.getCategory())) {
        final SubscriptionBase baseSubscription=subscriptionInternalApi.getBaseSubscription(subscription.getBundleId(),context);
        baseSubscriptionsToConsider=ImmutableList.<SubscriptionBase>of(baseSubscription);
      }
 else {
        return blockingStatesOnDisk;
      }
    }
 else {
      return blockingStatesOnDisk;
    }
  }
 catch (  SubscriptionBaseApiException e) {
    log.error("Error retrieving subscriptions for account record id " + context.getAccountRecordId(),e);
    throw new RuntimeException(e);
  }
  final BlockingState cancellationBlockingStateOnDisk=findEntitlementCancellationBlockingState(blockableId,blockingStatesOnDiskCopy);
  final List<EventsStream> eventsStreams;
  try {
    if (blockingStateType == null) {
      eventsStreams=eventsStreamBuilder.buildForAccount(context);
    }
 else {
      eventsStreams=ImmutableList.<EventsStream>of(eventsStreamBuilder.buildForEntitlement(baseSubscriptionsToConsider.iterator().next().getId(),context));
    }
  }
 catch (  EntitlementApiException e) {
    log.error("Error computing blocking states for addons for account record id " + context.getAccountRecordId(),e);
    throw new RuntimeException(e);
  }
  final DateTime now=clock.getUTCNow();
  for (  final SubscriptionBase baseSubscription : baseSubscriptionsToConsider) {
    final EventsStream eventsStream=Iterables.<EventsStream>find(eventsStreams,new Predicate<EventsStream>(){
      @Override public boolean apply(      final EventsStream input){
        return input.getSubscription().getId().equals(baseSubscription.getId());
      }
    }
);
    final Collection<BlockingState> blockingStatesNotOnDisk=eventsStream.computeAddonsBlockingStatesForFutureSubscriptionBaseEvents();
    for (    final BlockingState blockingState : blockingStatesNotOnDisk) {
      final boolean overrideCancellationBlockingStateOnDisk=cancellationBlockingStateOnDisk != null && isEntitlementCancellationBlockingState(blockingState) && blockingState.getEffectiveDate().isBefore(cancellationBlockingStateOnDisk.getEffectiveDate());
      if ((blockingStateType == null || (BlockingStateType.SUBSCRIPTION.equals(blockingStateType) && blockingState.getBlockedId().equals(blockableId))) && (cancellationBlockingStateOnDisk == null || overrideCancellationBlockingStateOnDisk)) {
        final BlockingStateModelDao blockingStateModelDao=new BlockingStateModelDao(blockingState,now,now);
        blockingStatesOnDiskCopy.add(BlockingStateModelDao.toBlockingState(blockingStateModelDao));
        if (overrideCancellationBlockingStateOnDisk) {
          blockingStatesOnDiskCopy.remove(cancellationBlockingStateOnDisk);
        }
      }
    }
  }
  return BLOCKING_STATE_ORDERING.immutableSortedCopy(blockingStatesOnDiskCopy);
}
