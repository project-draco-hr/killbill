{
  final Collection<BlockingState> blockingStatesOnDiskCopy=new LinkedList<BlockingState>(blockingStatesOnDisk);
  final Iterable<SubscriptionBase> baseSubscriptionsToConsider;
  try {
    if (blockableId == null) {
      final Iterable<SubscriptionBase> subscriptions=Iterables.<SubscriptionBase>concat(subscriptionInternalApi.getSubscriptionsForAccount(context).values());
      baseSubscriptionsToConsider=Iterables.<SubscriptionBase>filter(subscriptions,new Predicate<SubscriptionBase>(){
        @Override public boolean apply(        final SubscriptionBase input){
          return ProductCategory.BASE.equals(input.getCategory()) && !EntitlementState.CANCELLED.equals(input.getState());
        }
      }
);
    }
 else {
      final SubscriptionBase addOnSubscription;
      try {
        addOnSubscription=subscriptionInternalApi.getSubscriptionFromId(blockableId,context);
      }
 catch (      SubscriptionBaseApiException ignored) {
        return blockingStatesOnDisk;
      }
      if (ProductCategory.ADD_ON.equals(addOnSubscription.getCategory())) {
        final SubscriptionBase baseSubscription=subscriptionInternalApi.getBaseSubscription(addOnSubscription.getBundleId(),context);
        baseSubscriptionsToConsider=ImmutableList.<SubscriptionBase>of(baseSubscription);
      }
 else {
        return blockingStatesOnDisk;
      }
    }
  }
 catch (  SubscriptionBaseApiException e) {
    log.error("Error retrieving subscriptions for account record id " + context.getAccountRecordId(),e);
    throw new RuntimeException(e);
  }
  final DateTime now=clock.getUTCNow();
  for (  final SubscriptionBase baseSubscription : baseSubscriptionsToConsider) {
    final EventsStream eventsStream;
    try {
      eventsStream=eventsStreamBuilder.buildForEntitlement(baseSubscription.getId(),context);
    }
 catch (    EntitlementApiException e) {
      log.error("Error computing blocking states for addons for account record id " + context.getAccountRecordId(),e);
      throw new RuntimeException(e);
    }
    final Collection<BlockingState> blockingStatesNotOnDisk=eventsStream.computeAddonsBlockingStatesForFutureSubscriptionBaseEvents();
    for (    final BlockingState blockingState : blockingStatesNotOnDisk) {
      final BlockingStateModelDao blockingStateModelDao=new BlockingStateModelDao(blockingState,now,now);
      blockingStatesOnDiskCopy.add(BlockingStateModelDao.toBlockingState(blockingStateModelDao));
    }
  }
  return BLOCKING_STATE_ORDERING.immutableSortedCopy(blockingStatesOnDiskCopy);
}
