{
  final Map<String,Boolean> expectedNotificationsFred=new TreeMap<String,Boolean>();
  final Map<String,Boolean> expectedNotificationsBarney=new TreeMap<String,Boolean>();
  NotificationQueueService notificationQueueService=new DefaultNotificationQueueService(dbi,clock);
  NotificationConfig config=new NotificationConfig(){
    @Override public boolean isNotificationProcessingOff(){
      return false;
    }
    @Override public long getNotificationSleepTimeMs(){
      return 10;
    }
    @Override public int getDaoMaxReadyEvents(){
      return 1;
    }
    @Override public long getDaoClaimTimeMs(){
      return 60000;
    }
  }
;
  final NotificationQueue queueFred=notificationQueueService.createNotificationQueue("UtilTest","Fred",new NotificationQueueHandler(){
    @Override public void handleReadyNotification(    String notificationKey,    DateTime eventDateTime){
      log.info("Fred received key: " + notificationKey);
      expectedNotificationsFred.put(notificationKey,Boolean.TRUE);
      eventsReceived++;
    }
  }
,config);
  final NotificationQueue queueBarney=notificationQueueService.createNotificationQueue("UtilTest","Barney",new NotificationQueueHandler(){
    @Override public void handleReadyNotification(    String notificationKey,    DateTime eventDateTime){
      log.info("Barney received key: " + notificationKey);
      expectedNotificationsBarney.put(notificationKey,Boolean.TRUE);
      eventsReceived++;
    }
  }
,config);
  queueFred.startQueue();
  final UUID key=UUID.randomUUID();
  final DummyObject obj=new DummyObject("foo",key);
  final DateTime now=new DateTime();
  final DateTime readyTime=now.plusMillis(2000);
  final NotificationKey notificationKeyFred=new NotificationKey(){
    @Override public String toString(){
      return "Fred";
    }
  }
;
  final NotificationKey notificationKeyBarney=new NotificationKey(){
    @Override public String toString(){
      return "Barney";
    }
  }
;
  expectedNotificationsFred.put(notificationKeyFred.toString(),Boolean.FALSE);
  expectedNotificationsFred.put(notificationKeyBarney.toString(),Boolean.FALSE);
  dao.inTransaction(new Transaction<Void,DummySqlTest>(){
    @Override public Void inTransaction(    DummySqlTest transactional,    TransactionStatus status) throws Exception {
      transactional.insertDummy(obj);
      queueFred.recordFutureNotificationFromTransaction(transactional,readyTime,notificationKeyFred);
      log.info("posted key: " + notificationKeyFred.toString());
      queueBarney.recordFutureNotificationFromTransaction(transactional,readyTime,notificationKeyBarney);
      log.info("posted key: " + notificationKeyBarney.toString());
      return null;
    }
  }
);
  ((ClockMock)clock).setDeltaFromReality(3000);
  try {
    await().atMost(5,TimeUnit.SECONDS).until(new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        return eventsReceived >= 2;
      }
    }
);
    Assert.fail("There should only have been one event for the queue to pick up - it got more than that");
  }
 catch (  Exception e) {
  }
  Assert.assertTrue(expectedNotificationsFred.get(notificationKeyFred.toString()));
  Assert.assertFalse(expectedNotificationsFred.get(notificationKeyBarney.toString()));
}
