{
  final Map<NotificationKey,Boolean> expectedNotifications=new TreeMap<NotificationKey,Boolean>();
  final DefaultNotificationQueue queue=new DefaultNotificationQueue(dbi,clock,"test-svc","foo",new NotificationQueueHandler(){
    @Override public void handleReadyNotification(    final NotificationKey notificationKey,    final DateTime eventDateTime,    final UUID userToken,    final Long accountRecordId,    final Long tenantRecordId){
synchronized (expectedNotifications) {
        log.info("Handler received key: " + notificationKey);
        expectedNotifications.put(notificationKey,Boolean.TRUE);
        expectedNotifications.notify();
      }
    }
  }
,getNotificationConfig(false,100,1,10000),new InternalCallContextFactory(dbi,clock));
  queue.startQueue();
  final UUID key=UUID.randomUUID();
  final DummyObject obj=new DummyObject("foo",key);
  final DateTime now=new DateTime();
  final DateTime readyTime=now.plusMillis(2000);
  final NotificationKey notificationKey=new TestNotificationKey(key.toString());
  expectedNotifications.put(notificationKey,Boolean.FALSE);
  entitySqlDaoTransactionalJdbiWrapper.execute(new EntitySqlDaoTransactionWrapper<Void>(){
    @Override public Void inTransaction(    final EntitySqlDaoWrapperFactory<EntitySqlDao> entitySqlDaoWrapperFactory) throws Exception {
      entitySqlDaoWrapperFactory.transmogrify(DummySqlTest.class).insertDummy(obj);
      queue.recordFutureNotificationFromTransaction(entitySqlDaoWrapperFactory,readyTime,notificationKey,internalCallContext);
      log.info("Posted key: " + notificationKey);
      return null;
    }
  }
);
  ((ClockMock)clock).setDeltaFromReality(3000);
  await().atMost(1,MINUTES).until(new Callable<Boolean>(){
    @Override public Boolean call() throws Exception {
      return expectedNotifications.get(notificationKey);
    }
  }
);
  queue.stopQueue();
  Assert.assertTrue(expectedNotifications.get(notificationKey));
}
