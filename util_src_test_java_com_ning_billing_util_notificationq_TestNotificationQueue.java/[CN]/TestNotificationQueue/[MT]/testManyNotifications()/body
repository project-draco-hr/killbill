{
  final Map<NotificationKey,Boolean> expectedNotifications=new TreeMap<NotificationKey,Boolean>();
  final NotificationQueue queue=queueService.createNotificationQueue("test-svc","many",new NotificationQueueHandler(){
    @Override public void handleReadyNotification(    final NotificationKey notificationKey,    final DateTime eventDateTime,    final Long accountRecordId,    final Long tenantRecordId){
synchronized (expectedNotifications) {
        log.info("Handler received key: " + notificationKey.toString());
        expectedNotifications.put(notificationKey,Boolean.TRUE);
        expectedNotifications.notify();
      }
    }
  }
,config);
  queue.startQueue();
  final DateTime now=clock.getUTCNow();
  final int MAX_NOTIFICATIONS=100;
  for (int i=0; i < MAX_NOTIFICATIONS; i++) {
    final int nextReadyTimeIncrementMs=1000;
    final UUID key=UUID.randomUUID();
    final DummyObject obj=new DummyObject("foo",key);
    final int currentIteration=i;
    final NotificationKey notificationKey=new TestNotificationKey(new Integer(i).toString());
    expectedNotifications.put(notificationKey,Boolean.FALSE);
    dao.inTransaction(new Transaction<Void,DummySqlTest>(){
      @Override public Void inTransaction(      final DummySqlTest transactional,      final TransactionStatus status) throws Exception {
        transactional.insertDummy(obj);
        queue.recordFutureNotificationFromTransaction(transactional,now.plus((currentIteration + 1) * nextReadyTimeIncrementMs),accountId,notificationKey,internalCallContext);
        return null;
      }
    }
);
    if (i == 0) {
      ((ClockMock)clock).setDeltaFromReality(nextReadyTimeIncrementMs);
    }
 else {
      ((ClockMock)clock).addDeltaFromReality(nextReadyTimeIncrementMs);
    }
  }
  int nbTry=MAX_NOTIFICATIONS + 1;
  boolean success=false;
  do {
synchronized (expectedNotifications) {
      final Collection<Boolean> completed=Collections2.filter(expectedNotifications.values(),new Predicate<Boolean>(){
        @Override public boolean apply(        final Boolean input){
          return input;
        }
      }
);
      if (completed.size() == MAX_NOTIFICATIONS) {
        success=true;
        break;
      }
      log.info(String.format("BEFORE WAIT : Got %d notifications at time %s (real time %s)",completed.size(),clock.getUTCNow(),new DateTime()));
      expectedNotifications.wait(1000);
    }
  }
 while (nbTry-- > 0);
  queue.stopQueue();
  log.info("STEPH GOT SIZE " + Collections2.filter(expectedNotifications.values(),new Predicate<Boolean>(){
    @Override public boolean apply(    final Boolean input){
      return input;
    }
  }
).size());
  assertEquals(success,true);
}
