{
  final ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  final DataOutputStream dataStream=new DataOutputStream(outputStream);
  try {
    int lastTime=0;
    int lastDelta=0;
    int repeatCount=0;
    int chunkCounter=0;
    for (    byte[] times : timesList) {
      final ByteArrayInputStream byteStream=new ByteArrayInputStream(times);
      final DataInputStream byteDataStream=new DataInputStream(byteStream);
      int byteCursor=0;
      while (true) {
        final int opcode=byteDataStream.read();
        if (opcode == -1) {
          break;
        }
        byteCursor++;
        int newTime=0;
        int newCount=0;
        int newDelta=0;
        boolean useNewDelta=false;
        boolean nonDeltaTime=false;
        if (opcode == TimelineOpcode.FULL_TIME.getOpcodeIndex()) {
          newTime=byteDataStream.readInt();
          if (newTime < lastTime) {
            log.warn("In TimelineCoder.combineTimeLines(), the fulltime read is %d, but the lastTime is %d; setting newTime to lastTime",newTime,lastTime);
            newTime=lastTime;
          }
          byteCursor+=4;
          if (lastTime == 0) {
            writeTime(0,newTime,dataStream);
            lastTime=newTime;
            lastDelta=0;
            repeatCount=0;
            continue;
          }
 else           if (newTime - lastTime <= TimelineOpcode.MAX_DELTA_TIME) {
            newDelta=newTime - lastTime;
            useNewDelta=true;
            newCount=1;
          }
 else {
            nonDeltaTime=true;
          }
        }
 else         if (opcode <= TimelineOpcode.MAX_DELTA_TIME) {
          newTime=lastTime + opcode;
          newDelta=opcode;
          useNewDelta=true;
          newCount=1;
        }
 else         if (opcode == TimelineOpcode.REPEATED_DELTA_TIME_BYTE.getOpcodeIndex()) {
          newCount=byteDataStream.read();
          newDelta=byteDataStream.read();
          useNewDelta=true;
          byteCursor+=2;
          if (lastTime != 0) {
            newTime=lastTime + newDelta * newCount;
          }
 else {
            throw new IllegalStateException(String.format("In TimelineCoder.combineTimelines, lastTime is 0 byte opcode = %d, byteCursor %d, chunkCounter %d, chunk %s",opcode,byteCursor,chunkCounter,new String(Hex.encodeHex(times))));
          }
        }
 else         if (opcode == TimelineOpcode.REPEATED_DELTA_TIME_SHORT.getOpcodeIndex()) {
          newCount=byteDataStream.readUnsignedShort();
          newDelta=byteDataStream.read();
          useNewDelta=true;
          byteCursor+=3;
          if (lastTime != 0) {
            newTime=lastTime + newDelta * newCount;
          }
        }
 else {
          throw new IllegalStateException(String.format("In TimelineCoder.combineTimelines, Unrecognized byte opcode = %d, byteCursor %d, chunkCounter %d, chunk %s",opcode,byteCursor,chunkCounter,new String(Hex.encodeHex(times))));
        }
        if (lastTime == 0) {
          log.error("In combineTimelines(), lastTime is 0; byteCursor {}, chunkCounter {}, times {}",new Object[]{byteCursor,chunkCounter,new String(Hex.encodeHex(times))});
        }
 else         if (repeatCount > 0) {
          if (lastDelta == newDelta && newCount > 0) {
            repeatCount+=newCount;
            lastTime=newTime;
          }
 else {
            writeRepeatedDelta(lastDelta,repeatCount,dataStream);
            if (useNewDelta) {
              lastDelta=newDelta;
              repeatCount=newCount;
              lastTime=newTime;
            }
 else {
              writeTime(lastTime,newTime,dataStream);
              lastTime=newTime;
              lastDelta=0;
              repeatCount=0;
            }
          }
        }
 else         if (nonDeltaTime) {
          writeTime(lastTime,newTime,dataStream);
          lastTime=newTime;
          lastDelta=0;
          repeatCount=0;
        }
 else         if (lastDelta == 0) {
          lastTime=newTime;
          repeatCount=newCount;
          lastDelta=newDelta;
        }
      }
      chunkCounter++;
    }
    if (repeatCount > 0) {
      writeRepeatedDelta(lastDelta,repeatCount,dataStream);
    }
    dataStream.flush();
    return outputStream.toByteArray();
  }
 catch (  Exception e) {
    log.error("In combineTimesLines(), exception combining timelines",e);
    return new byte[0];
  }
}
