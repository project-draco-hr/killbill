{
  final SubscriptionSqlDao transSubDao=transactional.become(SubscriptionSqlDao.class);
  final BundleSqlDao transBundleDao=transactional.become(BundleSqlDao.class);
  final List<EntityAudit> audits=new ArrayList<EntityAudit>();
  Long recordId;
  final SubscriptionBundleData bundleData=bundleTransferData.getData();
  final SubscriptionBundle existingBundle=transBundleDao.getBundleFromAccountAndKey(bundleData.getAccountId().toString(),bundleData.getKey());
  if (existingBundle != null) {
    log.error(String.format("Attempted to create a bundle for account %s and key %s that already existed, skip...",bundleData.getAccountId().toString(),bundleData.getKey()));
    return;
  }
  for (  final SubscriptionMigrationData curSubscription : bundleTransferData.getSubscriptions()) {
    final SubscriptionData subData=curSubscription.getData();
    for (    final EntitlementEvent curEvent : curSubscription.getInitialEvents()) {
      transactional.insertEvent(curEvent,context);
      recordId=transactional.getRecordId(curEvent.getId().toString());
      audits.add(new EntityAudit(TableName.SUBSCRIPTION_EVENTS,recordId,ChangeType.INSERT));
      recordFutureNotificationFromTransaction(transactional,curEvent.getEffectiveDate(),new EntitlementNotificationKey(curEvent.getId()));
    }
    transSubDao.insertSubscription(subData,context);
    recordId=transSubDao.getRecordId(subData.getId().toString());
    audits.add(new EntityAudit(TableName.SUBSCRIPTIONS,recordId,ChangeType.INSERT));
    final EntitlementEvent finalEvent=curSubscription.getInitialEvents().get(curSubscription.getInitialEvents().size() - 1);
    notifyBusOfRequestedChange(transactional,subData,finalEvent);
  }
  transBundleDao.insertBundle(bundleData,context);
  recordId=transBundleDao.getRecordId(bundleData.getId().toString());
  audits.add(new EntityAudit(TableName.BUNDLES,recordId,ChangeType.INSERT));
  transSubDao.insertAuditFromTransaction(audits,context);
}
