{
  eventsDao.inTransaction(new Transaction<Void,EntitlementEventSqlDao>(){
    @Override public Void inTransaction(    final EntitlementEventSqlDao transactional,    final TransactionStatus status) throws Exception {
      final UUID subscriptionId=subscription.getId();
      EntitlementEvent cancelledEvent=null;
      final Date now=clock.getUTCNow().toDate();
      final List<EntitlementEvent> events=transactional.getFutureActiveEventForSubscription(subscriptionId.toString(),now);
      for (      final EntitlementEvent cur : events) {
        if (cur.getType() == EventType.API_USER && ((ApiEvent)cur).getEventType() == ApiEventType.CANCEL) {
          if (cancelledEvent != null) {
            throw new EntitlementError(String.format("Found multiple cancel active events for subscriptions %s",subscriptionId.toString()));
          }
          cancelledEvent=cur;
        }
      }
      if (cancelledEvent != null) {
        final List<EntityAudit> eventAudits=new ArrayList<EntityAudit>();
        final String cancelledEventId=cancelledEvent.getId().toString();
        transactional.unactiveEvent(cancelledEventId,context);
        final Long cancelledRecordId=transactional.getRecordId(cancelledEventId);
        eventAudits.add(new EntityAudit(TableName.SUBSCRIPTION_EVENTS,cancelledRecordId,ChangeType.UPDATE));
        EntitlementEvent prev=getLastStoredEventForSubscription(subscriptionId);
        for (        final EntitlementEvent cur : uncancelEvents) {
          transactional.insertEvent(cur,context);
          final Long recordId=transactional.getRecordId(cur.getId().toString());
          eventAudits.add(new EntityAudit(TableName.SUBSCRIPTION_EVENTS,recordId,ChangeType.INSERT));
          recordFutureNotificationFromTransaction(transactional,subscription,prev,cur,new EntitlementNotificationKey(cur.getId()));
          prev=cur;
        }
        transactional.insertAuditFromTransaction(eventAudits,context);
      }
      return null;
    }
  }
);
}
