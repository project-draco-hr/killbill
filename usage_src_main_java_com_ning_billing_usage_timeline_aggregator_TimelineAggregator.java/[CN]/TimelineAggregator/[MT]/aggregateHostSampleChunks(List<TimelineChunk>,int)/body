{
  final TimelineChunk firstTimesChunk=timelineChunks.get(0);
  final TimelineChunk lastTimesChunk=timelineChunks.get(timelineChunks.size() - 1);
  final int chunkCount=timelineChunks.size();
  final int sourceId=firstTimesChunk.getSourceId();
  final DateTime startTime=firstTimesChunk.getStartTime();
  final DateTime endTime=lastTimesChunk.getEndTime();
  final List<byte[]> timeParts=new ArrayList<byte[]>(chunkCount);
  try {
    final List<byte[]> sampleParts=new ArrayList<byte[]>(chunkCount);
    final List<Long> timelineChunkIds=new ArrayList<Long>(chunkCount);
    int sampleCount=0;
    for (    final TimelineChunk timelineChunk : timelineChunks) {
      timeParts.add(timelineChunk.getTimeBytesAndSampleBytes().getTimeBytes());
      sampleParts.add(timelineChunk.getTimeBytesAndSampleBytes().getSampleBytes());
      sampleCount+=timelineChunk.getSampleCount();
      timelineChunkIds.add(timelineChunk.getChunkId());
    }
    final byte[] combinedTimeBytes=timelineCoder.combineTimelines(timeParts,sampleCount);
    final byte[] combinedSampleBytes=sampleCoder.combineSampleBytes(sampleParts);
    final int timeBytesLength=combinedTimeBytes.length;
    final int totalSize=4 + timeBytesLength + combinedSampleBytes.length;
    log.debug("For sourceId {}, aggregationLevel {}, aggregating {} timelines ({} bytes, {} samples): {}",new Object[]{firstTimesChunk.getSourceId(),firstTimesChunk.getAggregationLevel(),timelineChunks.size(),totalSize,sampleCount});
    timelineChunksBytesCreated.addAndGet(totalSize);
    final int totalSampleCount=sampleCount;
    final TimelineChunk chunk=new TimelineChunk(0,sourceId,firstTimesChunk.getMetricId(),startTime,endTime,combinedTimeBytes,combinedSampleBytes,totalSampleCount,aggregationLevel + 1,false,false);
    chunksToWrite.add(chunk);
    chunkIdsToInvalidateOrDelete.addAll(timelineChunkIds);
    timelineChunksQueuedForCreation.incrementAndGet();
    if (chunkIdsToInvalidateOrDelete.size() >= config.getMaxChunkIdsToInvalidateOrDelete()) {
      performWrites();
    }
  }
 catch (  Exception e) {
    log.error(String.format("Exception aggregating level %d, sourceId %d, metricId %d, startTime %s, endTime %s",aggregationLevel,sourceId,firstTimesChunk.getMetricId(),startTime,endTime),e);
  }
}
