{
  return new WithAccountLock<Refund>().processAccountWithLock(locker,account.getExternalKey(),new WithAccountLockCallback<Refund>(){
    @Override public Refund doOperation() throws PaymentApiException {
      final BigDecimal refundAmount=computeRefundAmount(paymentId,specifiedRefundAmount,invoiceItemIdsWithAmounts,context);
      try {
        final PaymentModelDao payment=paymentDao.getPayment(paymentId,context);
        if (payment == null) {
          throw new PaymentApiException(ErrorCode.PAYMENT_NO_SUCH_SUCCESS_PAYMENT,paymentId);
        }
        int foundPluginCompletedRefunds=0;
        RefundModelDao refundInfo=null;
        BigDecimal totalAmountRefunded=BigDecimal.ZERO;
        final List<RefundModelDao> existingRefunds=paymentDao.getRefundsForPayment(paymentId,context);
        for (        final RefundModelDao cur : existingRefunds) {
          final BigDecimal existingPositiveAmount=cur.getAmount();
          if (existingPositiveAmount.compareTo(refundAmount) == 0) {
            if (cur.getRefundStatus() == RefundStatus.CREATED) {
              if (refundInfo == null) {
                refundInfo=cur;
              }
            }
 else {
              foundPluginCompletedRefunds++;
            }
          }
          if (cur.getRefundStatus() != RefundStatus.CREATED) {
            totalAmountRefunded=totalAmountRefunded.add(existingPositiveAmount);
          }
        }
        if (payment.getAmount().subtract(totalAmountRefunded).compareTo(refundAmount) < 0) {
          throw new PaymentApiException(ErrorCode.PAYMENT_REFUND_AMOUNT_TOO_LARGE);
        }
        if (refundInfo == null) {
          refundInfo=new RefundModelDao(account.getId(),paymentId,refundAmount,account.getCurrency(),isAdjusted);
          paymentDao.insertRefund(refundInfo,context);
        }
        final PaymentPluginApi plugin=getPaymentProviderPlugin(payment.getPaymentMethodId(),context);
        final int nbExistingRefunds=plugin.getNbRefundForPaymentAmount(account,paymentId,refundAmount,context.toCallContext());
        log.debug(String.format("found %d pluginRefunds for paymentId %s and amount %s",nbExistingRefunds,paymentId,refundAmount));
        if (nbExistingRefunds > foundPluginCompletedRefunds) {
          log.info("Found existing plugin refund for paymentId {}, skip plugin",paymentId);
        }
 else {
          plugin.processRefund(account,paymentId,refundAmount,context.toCallContext());
        }
        paymentDao.updateRefundStatus(refundInfo.getId(),RefundStatus.PLUGIN_COMPLETED,context);
        invoicePaymentApi.createRefund(paymentId,refundAmount,isAdjusted,invoiceItemIdsWithAmounts,refundInfo.getId(),context.toCallContext());
        paymentDao.updateRefundStatus(refundInfo.getId(),RefundStatus.COMPLETED,context);
        return new DefaultRefund(refundInfo.getId(),paymentId,refundInfo.getAmount(),account.getCurrency(),isAdjusted,refundInfo.getCreatedDate());
      }
 catch (      PaymentPluginApiException e) {
        throw new PaymentApiException(ErrorCode.PAYMENT_CREATE_REFUND,account.getId(),e.getMessage());
      }
catch (      InvoiceApiException e) {
        throw new PaymentApiException(e);
      }
    }
  }
);
}
