{
  final Collection<RefundModelDao> refundsToBeFixed=Collections2.filter(refunds,new Predicate<RefundModelDao>(){
    @Override public boolean apply(    final RefundModelDao in){
      return in.getRefundStatus() == RefundStatus.PLUGIN_COMPLETED;
    }
  }
);
  if (refundsToBeFixed.size() == 0) {
    return false;
  }
  try {
    final InternalCallContext context=internalCallContextFactory.createInternalCallContext(refundsToBeFixed.iterator().next().getId(),ObjectType.REFUND,"RefundProcessor",CallOrigin.INTERNAL,UserType.SYSTEM,null);
    final Account account=accountInternalApi.getAccountById(refundsToBeFixed.iterator().next().getAccountId(),context);
    new WithAccountLock<Void>().processAccountWithLock(locker,account.getExternalKey(),new WithAccountLockCallback<Void>(){
      @Override public Void doOperation() throws PaymentApiException {
        try {
          for (          final RefundModelDao cur : refundsToBeFixed) {
            invoiceApi.createRefund(cur.getPaymentId(),cur.getAmount(),cur.isAdjusted(),ImmutableMap.<UUID,BigDecimal>of(),cur.getId(),context);
            paymentDao.updateRefundStatus(cur.getId(),RefundStatus.COMPLETED,cur.getProcessedAmount(),cur.getProcessedCurrency(),context);
          }
        }
 catch (        InvoiceApiException e) {
          throw new PaymentApiException(e);
        }
        return null;
      }
    }
);
    return true;
  }
 catch (  AccountApiException e) {
    throw new PaymentApiException(e);
  }
}
