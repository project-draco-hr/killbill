{
  if (sourceIdList.size() == 0) {
    return;
  }
  dbi.withHandle(new HandleCallback<Void>(){
    @Override public Void withHandle(    final Handle handle) throws Exception {
      handle.setStatementLocator(new StringTemplate3StatementLocator(TimelineSqlDao.class));
      ResultIterator<TimelineChunk> iterator=null;
      try {
        final Query<Map<String,Object>> query=handle.createQuery("getSamplesBySourceRecordIdsAndMetricRecordIds").bind("startTime",DateTimeUtils.unixSeconds(startTime)).bind("endTime",DateTimeUtils.unixSeconds(endTime)).bind("tenantRecordId",context.getTenantRecordId()).define("sourceIds",JOINER.join(sourceIdList));
        if (metricIdList != null && !metricIdList.isEmpty()) {
          query.define("metricIds",JOINER.join(metricIdList));
        }
        iterator=query.map(timelineChunkMapper).iterator();
        while (iterator.hasNext()) {
          chunkConsumer.processTimelineChunk(iterator.next());
        }
        return null;
      }
  finally {
        if (iterator != null) {
          try {
            iterator.close();
          }
 catch (          Exception e) {
            log.error("Exception closing TimelineChunkAndTimes iterator for sourceIds {} and metricIds {}",sourceIdList,metricIdList);
          }
        }
      }
    }
  }
);
}
